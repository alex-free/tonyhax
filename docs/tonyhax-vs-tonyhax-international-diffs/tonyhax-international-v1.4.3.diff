diff --git a/tmp/og-tonyhax.0JX/loader/Makefile b/loader/Makefile
index f121ebf..955f671 100644
--- a/tmp/og-tonyhax.0JX/loader/Makefile
+++ b/loader/Makefile
@@ -2,6 +2,7 @@
 # Thanks to whoever made https://devhints.io/makefile!
 
 include ../variables.mk
+include ../variables-shared.mk
 
 LOADER_AUTOGEN := orca.inc
 LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
@@ -32,7 +33,7 @@ secondary.elf: secondary.ld $(LOADER_OBJECTS)
 tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
 	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
 
-BESLEM-99999TONYHAX: tonyhax.mcs
+HAX: tonyhax.mcs
 	bash ../util/mcs2raw.sh tonyhax.mcs
 
 tonyhax.exe: secondary.elf
diff --git a/loader/Makefile.ff9 b/loader/Makefile.ff9
new file mode 100644
index 0000000..28c53f8
--- /dev/null
+++ b/loader/Makefile.ff9
@@ -0,0 +1,40 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk
+include ../variables-shared.mk
+
+LOADER_AUTOGEN := orca.inc
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) FF9 tonyhax-ff9.mcs *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary-ff9.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary-ff9.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl-ff9.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl-ff9.mcs tonyhax-ff9.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax-ff9.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.freepsxboot b/loader/Makefile.freepsxboot
new file mode 100644
index 0000000..53df243
--- /dev/null
+++ b/loader/Makefile.freepsxboot
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.freepsxboot
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.rom b/loader/Makefile.rom
new file mode 100644
index 0000000..d036c91
--- /dev/null
+++ b/loader/Makefile.rom
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.rom
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.tocperfect b/loader/Makefile.tocperfect
new file mode 100644
index 0000000..572f600
--- /dev/null
+++ b/loader/Makefile.tocperfect
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.tocperfect
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.xstation b/loader/Makefile.xstation
new file mode 100644
index 0000000..47d55ac
--- /dev/null
+++ b/loader/Makefile.xstation
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.xstation
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/ap-bypass.c b/loader/ap-bypass.c
new file mode 100644
index 0000000..81a8642
--- /dev/null
+++ b/loader/ap-bypass.c
@@ -0,0 +1,2623 @@
+
+#include "bios.h"
+#include "str.h"
+#include "ap-bypass.h"
+//#include "debugscreen.h"
+
+bool cheat_engine_installed;
+
+uint8_t gs_code_type;
+
+int32_t code_address_ram_location = 0xD000;
+int32_t code_compare_ram_location = 0xD004;
+int32_t code_enable_ram_location = 0xD00C;  
+
+void clear_gs_code_line_ram () {
+	bzero((void*)0xD000, 0x600); 
+// 255 code line limit * 6 bytes per code + 6 bytes of padding = 1536/0x600. 0xD000-0xD600 are to be zeroed out to ensure correct parsing by the cheat engine (used for gs codes loaded via memory card AND for APv2 bypasses). Every BIOS besides v3.0 has enough garbage? in this 'reserved' area to break the cheat engine parsing if we don't do this. Previously this zero-out was always done regardless of if the GameShark feature was actually being used. Now this is only done if the GameShark engine is active to fix issue 39: https://github.com/alex-free/tonyhax/issues/39 .
+}
+
+void add_8bit_code(const uint32_t gs1, const uint8_t gs2, const uint8_t gs_code_type) {
+	if(code_address_ram_location == 0xD000)
+		clear_gs_code_line_ram(); // before writing first code line clear RAM
+
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 1);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_16bit_code(const uint32_t gs1, const uint16_t gs2, const uint8_t gs_code_type) {
+
+	if(code_address_ram_location == 0xD000)
+		clear_gs_code_line_ram(); // before writing first code line clear RAM
+
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 2);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+// size optimization wrapper, instead of specifying 0xD0 or 0x80 each time we add a code via built-in ap bypass system
+void add_80_code(const uint32_t gs1, const uint16_t gs2) {
+	add_16bit_code(gs1, gs2, 0x80);
+}
+
+void add_D0_code(const uint32_t gs1, const uint16_t gs2) {
+	add_16bit_code(gs1, gs2, 0xD0);
+}
+
+void install_cheat_engine() {
+// generate with `scripts/stealth-engine-xxd.sh` after compiling .EXE file with No $ PSX Emu Assembler
+const unsigned char cheat_engine_v1_0_4[] = {
+0xe0, 0xff, 0xbd, 0x27, 0x00, 0x00, 0xa4, 0xaf,
+  0x04, 0x00, 0xa5, 0xaf, 0x08, 0x00, 0xa6, 0xaf, 0x0c, 0x00, 0xa7, 0xaf,
+  0x00, 0x00, 0x04, 0x3c, 0x00, 0xd0, 0x84, 0x34, 0x00, 0x00, 0x00, 0x00,
+  0x0c, 0x00, 0x86, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0xc0, 0x10,
+  0xd0, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x00, 0xc7, 0x10,
+  0xd1, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x00, 0xc7, 0x10,
+  0xd2, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x61, 0x00, 0xc7, 0x10,
+  0xd3, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0xc7, 0x10,
+  0xe0, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0xc7, 0x10,
+  0xe1, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0xc7, 0x10,
+  0xe2, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0xc7, 0x10,
+  0xe3, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0xc7, 0x10,
+  0x80, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc7, 0x10,
+  0x30, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0xc7, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00,
+  0x73, 0x00, 0xc7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x07, 0x34,
+  0x1c, 0x00, 0x86, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0xc7, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa0, 0x10, 0x00, 0x84, 0x24,
+  0xcf, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94,
+  0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa4,
+  0x10, 0x00, 0x84, 0x24, 0xc8, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+  0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00, 0xe3, 0xff, 0xc5, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0xbe, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0xd9, 0xff, 0xc5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24,
+  0xb4, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90,
+  0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90,
+  0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xc5, 0x14, 0x00, 0x00, 0x00, 0x00,
+  0x20, 0x00, 0x84, 0x24, 0xaa, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+  0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00, 0xc5, 0xff, 0xc5, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0xa0, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x94, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x88, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x7c, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x70, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x85, 0x90, 0x10, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa0, 0x20, 0x00, 0x84, 0x24,
+  0x69, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x85, 0x94,
+  0x10, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa4,
+  0x20, 0x00, 0x84, 0x24, 0x62, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xa4, 0x8f, 0x04, 0x00, 0xa5, 0x8f, 0x08, 0x00, 0xa6, 0x8f,
+  0x0c, 0x00, 0xa7, 0x8f, 0x20, 0x00, 0xbd, 0x27, 0x01, 0x00, 0x1a, 0x3c,
+  0xfc, 0xcf, 0x5a, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x03,
+  0x00, 0x00, 0x00, 0x00
+};
+
+	//debug_write("Installing MottZilla AP Engine");
+	memcpy((void*)0xC000, (void*)cheat_engine_v1_0_4, sizeof(cheat_engine_v1_0_4)); // Copy MottZilla's cheat engine assembly binary to 0xC000
+	const uint32_t b0_jump = (*(uint32_t*)0xB4) & 0xFFFF;
+	//debug_write("Got jump address for B0 functions : %x", (uint32_t) b0_jump);
+	const uint32_t b0_base = (*(uint32_t*)(b0_jump + 4)) & 0xFFFF;
+	//debug_write("Got base address for B0 table : %x", (uint32_t) b0_base);
+	const uint32_t b0_entry = b0_base + (0x17 * 4);
+	//debug_write("Got B0 table entry address : %x", (uint32_t) b0_entry);
+	const uint32_t old_table_val = *(uint32_t*) b0_entry;
+	//debug_write("B0 table entry to modify has the original contents : %x", (uint32_t) old_table_val);
+	memcpy((void*)0xCFFC, (void*)&old_table_val, sizeof(old_table_val)); // Copy the original 32 bit number of the B table entry we want to modify to 0xCFFC
+	const uint16_t redirect = 0xC000;
+	memcpy((void*)b0_entry, &redirect, 2); // Write the value 0xC000 to table entry we want to modify
+	//for(volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	cheat_engine_installed = 1;
+}
+
+void activate_anti_anti_piracy(char * bootfile, const int32_t load_addr) 
+{
+	int32_t ver_check;
+	uint8_t ver_check_val;
+	int8_t bootfile_len = strlen(bootfile);
+	/*
+	lowest possible ap bootfile len is 19
+    cdrom:\\XXXX_XXX.XX;1 = 21 len	
+    cdrom:\XXXX_XXX.XX;1 = 20 len	
+    cdrom:XXXX_XXX.XX;1 = 19 len		
+	*/
+	//debug_write("Bootfile len: %d", bootfile_len);
+
+	// Aprip fake VC0 bypass code type constants
+	const uint16_t fake_vc0_bypass_compare_val = 0x001E;
+	const uint16_t fake_vc0_bypass_patch_val = 0x0000;
+
+	// Aprip fake PAL BIOS bypass code type constants
+	const uint16_t fake_pal_bios_bypass_compare_val = 0x1062;
+	const uint16_t fake_pal_bios_bypass_patch_val = 0x1800;
+
+	// Many pre-existing 'skip mod check' or 'force routine ok' type codes from back in the day seem to share these values, so they are a const
+	const uint16_t common_routine_return_compare_val = 0x1040;
+	const uint16_t common_routine_return_patch_val = 0x1000;
+
+	// this is less expensive space-wise then using strncmp
+	if(bootfile_len >= 19) {
+		bootfile = &bootfile[bootfile_len-13]; // strip bootfile to last 13 bytes, XXXX_XXX.XX;1
+		//debug_write("Bootfile stripped 1: %s", bootfile);
+		bootfile[11] = 0; // replace ; with termination. So XXXX_XXX.XX;1 becomes XXXX_XXX.XX for less expensive (space-wise) strcmps
+		//debug_write("Bootfile stripped 2: %s", bootfile);
+		//for(volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause	
+	} else {
+		return; 
+		// Speed optimization. All anti-piracy games currently have an pre-stripped bootfile name that is at least 19 bytes long. So if the bootfile happens to have something like 'cdrom://MAIN.EXE;1' (which is 18 in length) , we already know not to bother even checking for an anti-piracy bootfile match to apply codes for (which takes time in itself to do as well).
+	}
+
+// Animetic Story Game 1: Card Captor Sakura
+   	if(
+	((strcmp("SLPS_018.30", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SLPS_018.31", bootfile)) == 0) // Japan Disc 2
+	) { // 2 disc game
+		/*
+		D001516A 1040
+		8001516A 1000
+		code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_c.shtml
+    	*/
+    	add_D0_code(0x8001516A, common_routine_return_compare_val);
+		add_80_code(0x8001516A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Alundra 2
+	((strcmp("SCPS_101.15", bootfile)) == 0) { // Japan
+		/*
+		D004E91A 1040
+		8004E91A 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+    	*/
+    	add_D0_code(0x8004E91A, common_routine_return_compare_val);
+		add_80_code(0x8004E91A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Arc The Lad III
+	(
+	((strcmp("SCPS_101.06", bootfile)) == 0) // Japan Rev 0/Rev 1 Disc 1
+	|| ((strcmp("SCPS_101.07", bootfile)) == 0) // Japan Rev 0/Rev 1 Disc 2
+	) {
+		ver_check = (load_addr + 0x20); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0x8C)) // Rev 0
+		{
+			/*
+			D0021DF6 1040
+			80021DF6 1000
+			code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+    		*/
+	    	add_D0_code(0x80021DF6, common_routine_return_compare_val);
+			add_80_code(0x80021DF6, common_routine_return_patch_val);
+    		install_cheat_engine();
+    	} else { // Rev 1
+ 			/*
+			D0022206 1040
+			80022206 1000
+			my code via aprip gameshark code conversion
+    		*/
+	    	add_D0_code(0x80022206, common_routine_return_compare_val);
+			add_80_code(0x80022206, common_routine_return_patch_val);
+    		install_cheat_engine();		
+    	}
+    } else if
+
+// Beatmania featuring Dreams Come True
+   	((strcmp("SLPM_865.97", bootfile)) == 0) { // Japan
+		/*
+		D012129A 1040
+		8012129A 1000
+		skip routine code
+		code from https://gamehacking.org/game/93343 by davintheravin
+		did not need C1 code: "Code Execution Delay - Delays activation of codes by &value." because "Line starting w/ 'C1' needed for GS version 2.41 and up." and this tested okay. Info from "Info/Note" on that link
+		*/
+	    add_D0_code(0x8012129A, common_routine_return_compare_val);
+		add_80_code(0x8012129A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Beatmania Best Hits
+   	((strcmp("Slpm_865.96", bootfile)) == 0) { // Japan Rev 0/Rev 1
+		// not a typo, weird asf filename
+		/*
+		D01500FE 1062
+		801500FE 1800
+		code generated via aprip
+    	*/
+	    add_D0_code(0x801500FE, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801500FE, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Beat Mania: The Sound of Tokyo
+	((strcmp("SLPM_867.69", bootfile)) == 0) { // Japan
+    	/*
+		D01338FE 1062
+		801338FE 1800
+		my code via aprip
+    	*/
+	    add_D0_code(0x801338FE, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801338FE, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Beat Mania 6thMix + Core Remix
+	((strcmp("SLPM_870.12", bootfile)) == 0) { // Japan
+		/*
+		D0130822 1062
+		80130822 1800
+    	my code generated via aprip
+    	*/
+	    add_D0_code(0x80130822, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x80130822, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Bishi Bashi Special 2
+	((strcmp("SLPM_862.67", bootfile)) == 0) { // Japan
+		/*
+		D009818A 1040
+		8009818A 1000
+		code from https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+		*/
+	    add_D0_code(0x8009818A, common_routine_return_compare_val);
+		add_80_code(0x8009818A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Boku no Natsuyasumi: Summer Holiday 20th Century
+	((strcmp("SCPS_100.88", bootfile)) == 0) { // Japan
+		/*
+		D004921E 1062
+		8004921E 1800
+    	my code generated via aprip
+    	*/
+	    add_D0_code(0x8004921E, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x8004921E, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Breath of Fire IV
+   	((strcmp("SLPS_027.28", bootfile)) == 0) { // Japan / USA E3 2000 Beta Build
+		/*
+		D01CE39A 1062
+		801CE39A 1800
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x801CE39A, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801CE39A, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Bust A Move 2: Dance Tengoku Mix
+   	((strcmp("SLPM_862.19", bootfile)) == 0) { // Japan
+		/*
+		D008FB02 1040
+		8008FB02 1000
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x8008FB02, common_routine_return_compare_val);
+		add_80_code(0x8008FB02, common_routine_return_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Capcom vs. SNK: Millennium Fight 2000 Pro
+   	((strcmp("SLPM_870.53", bootfile)) == 0) { // Japan
+		/*
+		D0033BCE 1062
+		80033BCE 1800
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x80033BCE, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x80033BCE, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Chase The Express
+   	(
+	((strcmp("SCPS_101.09", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SCPS_101.10", bootfile)) == 0) // Japan Disc 2
+	|| ((strcmp("PAPX_901.06", bootfile)) == 0) // Japan Demo 1
+	|| ((strcmp("PCPX_961.89", bootfile)) == 0) // Japan Demo 2
+	) {
+		/*
+		D00EA6DE 1040
+		800EA6DE 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_c.shtml
+    	*/
+	    add_D0_code(0x800EA6DE, common_routine_return_compare_val);
+		add_80_code(0x800EA6DE, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Chocobo Racing: Genkai e no Road
+  	((strcmp("SLPS_019.51", bootfile)) == 0) { // Japan
+		/*
+		D00AB72A 1040
+		800AB72A 1000
+		code from https://consolecopyworld.com/psx/psx_game_codes_c.shtml (Bung Japan)
+    	*/
+	    add_D0_code(0x800AB72A, common_routine_return_compare_val);
+		add_80_code(0x800AB72A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if 
+
+// Crash Bash
+  	((strcmp("SCUS_945.70", bootfile)) == 0) { // USA
+		/*
+		D002D51E 1040
+		8002D51E 1000
+		code from GameHacking: https://gamehacking.org/game/88640, skips mod check
+    	*/
+	    add_D0_code(0x8002D51E, common_routine_return_compare_val);
+		add_80_code(0x8002D51E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if 
+
+   	((strcmp("SCPS_101.40", bootfile)) == 0) { // Japan
+		/*
+		D002D7EE 1040
+		8002D7EE 1000
+		code from GameHacking: https://gamehacking.org/game/93827, skips mod check
+    	*/
+	    add_D0_code(0x8002D7EE, common_routine_return_compare_val);
+		add_80_code(0x8002D7EE, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Crash Bandicoot Racing
+   	((strcmp("SCPS_101.18", bootfile)) == 0) { // Japan
+		/*
+		D001259A 1040
+		8001259A 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml (yes it's on the wrong lettered page)
+    	*/
+	    add_D0_code(0x8001259A, common_routine_return_compare_val);
+		add_80_code(0x8001259A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("PCPX_961.83", bootfile)) == 0) { // Japan Demo
+		/*
+    	D001255E 1040
+    	8001255E 1040
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x8001255E, common_routine_return_compare_val);
+		add_80_code(0x8001255E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Cool Boarders 2001
+   	(
+	((strcmp("SCUS_946.25", bootfile)) == 0) // USA Demo
+	|| ((strcmp("SCUS_945.97", bootfile)) == 0) // USA
+	)
+	{ 
+		/*
+		D00B1146 1062
+		800B1146 1800
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x800B1146, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x800B1146, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dancing Blade Katte ni Momotenshi II: Tears of Eden
+   	(
+	((strcmp("SLPM_862.10", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SLPM_862.11", bootfile)) == 0) // Japan Disc 2
+	|| ((strcmp("SLPM_862.12", bootfile)) == 0) // Japan Disc 3
+	)
+	{ 
+		/*
+		D019E272 1040
+		8019E272 1000
+		force ok
+		code from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+	    add_D0_code(0x8019E272, common_routine_return_compare_val);
+		add_80_code(0x8019E272, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution
+   	((strcmp("SLPM_862.22", bootfile)) == 0) { // Japan
+		/*
+		D001E160 FFF2
+		8001E160 0001
+		bypass checksum
+		code from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+	    add_D0_code(0x8001E160, 0xFFF2);
+		add_80_code(0x8001E160, 0x0001);
+		/*
+		D01B6F20 0003
+		801B6F20 0001
+		pro action replay bypass
+		code from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+	    add_D0_code(0x801B6F20, 0x0003);
+		add_80_code(0x801B6F20, 0x0001);
+		/*
+		D01B76A8 DE07
+		801B76A8 DDFE
+		mod-chip bypass
+		code from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+	    add_D0_code(0x801B76A8, 0xDE07);
+		add_80_code(0x801B76A8, 0xDDFE);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Best Hits
+   	((strcmp("SLPM_866.93", bootfile)) == 0) { // Japan
+		/*
+		D010024E 1062
+		8010024E 1800
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x8010024E, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x8010024E, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Disney's Rave
+   	((strcmp("SLPM_866.67", bootfile)) == 0) { // Japan
+		/*
+		D0190182 1062
+		80190182 1800
+		code generated via aprip
+    	*/
+	    add_D0_code(0x80190182, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x80190182, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Extra Mix
+   	((strcmp("SLPM_868.31", bootfile)) == 0) { // Japan
+		/*
+		D00E8266 1062
+		800E8266 1800
+		code generated via aprip
+    	*/
+	    add_D0_code(0x800E8266, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x800E8266, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution 2nd Remix
+   	((strcmp("SLPM_862.52", bootfile)) == 0) { // Dance Dance Revolution 2nd Remix Append Club Vol 1 and Dance Dance Revolution 2nd Remix Append Club Vol 2 discs are booted with a 'disc change' feature within Dance Dance Revolution 2nd Remix (which is a 'base' disc when booting the others, kind of like DLC).
+		/*
+		Dance Dance Revolution 2nd Remix:
+		D00200A6 1040
+		800200A6 1000
+		*/
+	    add_D0_code(0x800200A6, common_routine_return_compare_val);
+		add_80_code(0x800200A6, common_routine_return_patch_val);
+		/*
+		D0020D64 FFF2
+		80020D64 0001
+		*/
+    	add_D0_code(0x80020D64, 0xFFF2);
+    	add_80_code(0x80020D64, 0x0001);
+		/*
+		D01C1BE4 FFF2
+		801C1BE4 0001
+		*/
+    	add_D0_code(0x801C1BE4, 0xFFF2);
+    	add_80_code(0x801C1BE4, 0x0001);
+
+		/*
+		D01C1C7A 0C07
+		801C1C7A 3002
+		*/
+    	add_D0_code(0x801C1C7A, 0x0C07);
+    	add_80_code(0x801C1C7A, 0x3002);
+		/*
+		D01C2936 1040
+		801C2936 1000
+		*/
+    	add_D0_code(0x801C2936, common_routine_return_compare_val);
+    	add_80_code(0x801C2936, common_routine_return_patch_val);
+		/*
+		Dance Dance Revolution 2nd Remix Append Club Vol 1
+		D01C2A18 0C92
+		801C2A18 0AA7
+		*/
+    	add_D0_code(0x801C2A18, 0x0C92);
+    	add_80_code(0x801C2A18, 0x0AA7);
+		/*
+		D01C2EA2 1040
+		801C2EA2 1000
+		*/
+    	add_D0_code(0x801C2EA2,common_routine_return_compare_val);
+    	add_80_code(0x801C2EA2, common_routine_return_patch_val);
+		/*
+		D01C26DE 1062
+		801C26DE 1800
+		my code via aprip
+		*/
+    	add_D0_code(0x801C26DE,fake_pal_bios_bypass_compare_val);
+    	add_80_code(0x801C26DE, fake_pal_bios_bypass_patch_val);
+		/*
+		Dance Dance Revolution 2nd Remix Append Club Vol 2
+		D01C2F32 1040
+		801C2F32 1000
+		*/
+    	add_D0_code(0x801C2F32, common_routine_return_compare_val);
+    	add_80_code(0x801C2F32, common_routine_return_patch_val);
+		/*
+		D01C2AA8 0CB6
+		801C2AA8 0ACB
+		*/
+    	add_D0_code(0x801C2AA8, 0x0CB6);
+    	add_80_code(0x801C2AA8, 0x0ACB);
+		/*
+		D01C276E 1062
+		801C276E 1800
+		my code via aprip
+		*/
+    	add_D0_code(0x801C276E,fake_pal_bios_bypass_compare_val);
+    	add_80_code(0x801C276E, fake_pal_bios_bypass_patch_val);
+		// non-aprip generated codes are from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml 
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: 3rd Mix
+   	((strcmp("SLPM_865.03", bootfile)) == 0) { // Japan
+		/*
+		D00C19A2 1062
+		800C19A2 1800
+		my code generated via aprip
+    	*/
+    	add_D0_code(0x800C19A2, fake_pal_bios_bypass_compare_val);
+    	add_80_code(0x800C19A2, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: 4th Mix
+   	((strcmp("SLPM_867.52", bootfile)) == 0) { // Japan
+		/*
+		D00E824E 1062
+		800E824E 1800
+		my code generated via aprip
+    	*/
+    	add_D0_code(0x800E824E, fake_pal_bios_bypass_compare_val);
+    	add_80_code(0x800E824E, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: 5th Mix
+   	((strcmp("SLPM_868.97", bootfile)) == 0) { // Japan
+		/*
+		D0174306 1062
+		80174306 1800
+		my code generated via aprip
+    	*/
+    	add_D0_code(0x80174306, fake_pal_bios_bypass_compare_val);
+    	add_80_code(0x80174306, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dancing Stage featuring Dreams Come True
+   	((strcmp("SLPM_865.05", bootfile)) == 0) { // Japan
+		/*
+		D0190182 1062
+		80190182 1800
+		code generated via aprip
+    	*/
+    	add_D0_code(0x80190182, fake_pal_bios_bypass_compare_val);
+    	add_80_code(0x80190182, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dancing Stage featuring True Kiss Destination
+   	((strcmp("SLPM_864.11", bootfile)) == 0) { // Japan
+		/*
+		D019117A 1040
+		8019117A 1000
+		skip mod check
+		code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+    	add_D0_code(0x8019117A, common_routine_return_compare_val);
+    	add_80_code(0x8019117A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dino Crisis
+	((strcmp("SLUS_009.22", bootfile)) == 0) { // USA Rev 0/USA Rev 1
+		ver_check = (load_addr + 0x61); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if(ver_check_val == 0xD0) { // Rev 0
+			/*
+			D0149004 959C
+			80149004 9E64
+			Found independently by MottZilla, but actually turns out to be the same code by Epson found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+			*/
+  		  	add_D0_code(0x80149004, 0x959C);
+  		  	add_80_code(0x80149004, 0x9E64);
+			install_cheat_engine();
+		} else { // Rev 1
+			/*
+			D0148004 8658
+			80148004 8F20
+			my code, the anti-piracy table just moved memory addresses between versions :)
+			*/
+ 			add_D0_code(0x80148004, 0x8658);
+ 			add_80_code(0x80148004, 0x8F20);
+			install_cheat_engine();
+    	}
+	} else if
+
+   	((strcmp("SLPS_021.80", bootfile)) == 0) { // Japan
+		/*
+		D0149004 959C
+		80149004 9E64
+		Found independently by MottZilla, but actually turns out to be the same code by Epson found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml . Yes this is the same code as the USA rev 0 one.
+		*/
+  		add_D0_code(0x80149004, 0x959C);
+  		add_80_code(0x80149004, 0x9E64);
+		install_cheat_engine();
+    } else if
+
+// Dino Crisis 2
+   	((strcmp("SLPM_866.27", bootfile)) == 0) { // Japan
+	  	/*
+		D00D639E 1062
+		800D639E 1800
+		my code via aprip
+		*/
+		add_D0_code(0x800D639E, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x800D639E, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_805.73", bootfile)) == 0) { // Japan Demo
+	  	/*
+		D00C9DA6 1062
+		800C9DA6 1800
+		my code via aprip
+		*/
+		add_D0_code(0x800C9DA6, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x800C9DA6, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Disney's The Emperor's New Groove
+   	((strcmp("SCUS_945.71", bootfile)) == 0) { // USA
+	  	/*
+		D004C6E2 1062
+		8004C6E2 1800
+		my code via aprip
+		*/
+		add_D0_code(0x8004C6E2, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x8004C6E2, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCES_030.10", bootfile)) == 0) { // Europe
+  		/*
+		D004CBDA 1062
+		8004CBDA 1800
+		my code via aprip
+		*/
+		add_D0_code(0x8004CBDA, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x8004CBDA, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Doko Demo Issho
+	(
+	((strcmp("SCPS_100.92", bootfile)) == 0) // Japan Rev 0/Japan Rev 1
+	|| ((strcmp("SCPM_850.06", bootfile)) == 0) // Japan Calpis Water Version 
+	) { 
+		/*
+		these 3 codes work for Japan Rev 0, Japan Rev 1, and Japan Calpis Water Version.
+	
+		D01207E8 2021
+		801207E4 FFF6
+		code 1/3 from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+		*/
+  		add_D0_code(0x801207E8, 0x2021);
+  		add_80_code(0x801207E4, 0xFFF6);
+		/*
+		D01207E8 2021
+		801207E6 1000
+		code 2/3 from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+  		*/
+		add_D0_code(0x801207E8, 0x959C);
+  		add_80_code(0x801207E6, common_routine_return_patch_val);
+		/*
+		D0151AE2 1040
+		80151AE2 1000
+		code 3/3 from https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+  		*/
+		add_D0_code(0x80151AE2, common_routine_return_compare_val);
+  		add_80_code(0x80151AE2, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+	((strcmp("PCPX_961.52", bootfile)) == 0) { // Japan Demo 1
+		/*
+		D0151E10 2021
+		80151E06 FFF6
+		code 1/3 via aprip conversion
+		*/
+  		add_D0_code(0x80151E10, 0x959C);
+  		add_80_code(0x80151E06, common_routine_return_patch_val);
+		/*
+		D0151E10 2021
+		80151E08 1000
+		code 2/3 via aprip conversion
+  		*/
+		add_D0_code(0x80151E10, 0x2021);
+  		add_80_code(0xD0151E08, common_routine_return_patch_val);
+		/*
+		00151AE0: 0E
+		00151AE1: 00
+		00151AE2: 40
+		00151AE3: 10
+		00151AE4: 00
+		00151AE5: 00
+
+		end of pattern match, it works though! Manual conversion for this last one was needed. Below bytes don't match from Japan Rev 1 to this demo:
+
+		00151AE6: 00
+		00151AE7: 00
+		00151AE8: D5
+		00151AE9: 46
+		00151AEA: 05
+		00151AEB: 0C
+		00151AEC: 21
+		00151AED: 20
+		00151AEE: 00
+		00151AEF: 00
+
+		D0151D9A 1040
+		80151D9A 1000
+		code 3/3 via aprip conversion
+  		*/
+		add_D0_code(0x80151D9A, common_routine_return_compare_val);
+  		add_80_code(0x80151D9A, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+// TODO: I Can not find Japan Demo 2 image (PAPX 90086) http://redump.org/disc/83081/ to add support yet
+
+// Exciting Bass 2
+   	((strcmp("SLPM_862.95", bootfile)) == 0) { // Japan
+		/*
+		D00177BA 1040
+		800177BA 1000	
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_e.shtml
+  		*/
+  		add_D0_code(0x800177BA, common_routine_return_compare_val);
+  		add_80_code(0x800177BA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Exciting Bass 3
+   	((strcmp("SLPM_867.29", bootfile)) == 0) { // Japan
+		/*
+		D00225E2 1062
+		800225E2 1800
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x800225E2, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x800225E2, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Final Fantasy VIII
+	(
+   	((strcmp("SLPS_018.80", bootfile)) == 0) // Japan Disc 1
+   	|| ((strcmp("SLPS_018.81", bootfile)) == 0) // Japan Disc 2
+	|| ((strcmp("SLPS_018.82", bootfile)) == 0) // Japan Disc 3
+	|| ((strcmp("SLPS_018.83", bootfile)) == 0) // Japan Disc 3
+	) {
+		/*
+		D009B182 0000
+		8009B182 2402
+		code from https://consolecopyworld.com/psx/psx_game_codes_f.shtml by Asian Game Shark Code Creator (NOTE: CODE has typo on consolecopyworld page)
+		*/
+        add_D0_code(0x8009B182, 0x0000);
+        add_80_code(0x8009B182, 0x2402);
+		install_cheat_engine();
+	} else if
+
+// Gekitotsu Toma L'Arc - L'Arc en Ciel vs Tomarunner
+   	((strcmp("SCPS_101.34", bootfile)) == 0) { // Japan
+		/*
+		D016385E 1062
+		8016385E 1800
+		my code via aprip
+  		*/
+		add_D0_code(0x8016385E, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x8016385E, fake_pal_bios_bypass_patch_val);
+  		install_cheat_engine();
+    } else if
+
+// Glint Glitters
+   	((strcmp("SLPM_862.00", bootfile)) == 0) { // Japan
+		/*
+		D01B2816 1040
+		801B2816 1000
+		code from https://gamehacking.org/game/94731
+		this code is a 'force ok' type code. the whole routine still runs the test commands and readtoc, but it forces ok for the result of the test commands
+  		*/
+		add_D0_code(0x801B2816, common_routine_return_compare_val);
+		add_80_code(0x801B2816, common_routine_return_patch_val);
+		/*
+		D01B3188 001E
+		801B3188 0000
+		my code via aprip. this disables readtoc so in combination with the code above this does allow a non-stealth mod-chip console to work as well as a stock console. Verified with SCPH-5501 non-stealth mod-chipped, and SCPH-101 stock.
+  		*/
+		add_D0_code(0x801B3188, fake_vc0_bypass_compare_val);
+		add_80_code(0x801B3188, fake_vc0_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Global Force: Shin Sentou Kokka
+   	((strcmp("SCPS_100.82", bootfile)) == 0) { // Japan Rev 0/Japan Rev 1
+		// same codes works for both Japan Rev 0 and Japan Rev 1
+		/*
+		D01E8CC4 2021
+		801E8CC0 FFF6
+		code 1/2 from https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+		skips mod-check
+		*/
+		add_D0_code(0x801E8CC4, 0x2021);
+		add_80_code(0x801E8CC0, 0xFFF6);
+		/*
+		D01E8CC4 2021
+		801E8CC2 1000
+		code 2/2 from https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+		skips mod-check
+		*/
+		add_D0_code(0x801E8CC4, 0x2021);
+		add_80_code(0x801E8CC2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("PCPX_961.46", bootfile)) == 0) { // Japan Demo
+		/*
+		D01E91EC 2021
+		801E91E8 FFF6
+		code 1/2 via aprip conversion
+		skips mod-check
+		*/
+		add_D0_code(0x801E91EC, 0x2021);
+		add_80_code(0x801E91E8, 0xFFF6);
+		/*
+		D01E91EC 2021
+		801E91EA 1000
+		code 2/2 via aprip conversion
+		skips mod-check
+		*/
+		add_D0_code(0x801E91EC, 0x2021);
+		add_80_code(0x801E91EA, 0x1000);
+		install_cheat_engine();
+    } else if
+
+// Goo! Goo! Soundry
+   	((strcmp("SLPM_862.50", bootfile)) == 0) { // Japan
+		/*
+		D0012B66 1040
+		80012B66 1000
+		code from https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+		skips mod-check
+		*/
+		add_D0_code(0x80012B66, common_routine_return_compare_val);
+		add_80_code(0x80012B66, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Grind Session
+   	((strcmp("SCUS_945.68", bootfile)) == 0) { // USA
+		/*
+		D0013F3A 1062
+		80013F3A 1800
+		my code via aprip
+    	*/
+  		add_D0_code(0x80013F3A, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80013F3A, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Guitar Freaks
+   	((strcmp("SLPM_862.65", bootfile)) == 0) { // Japan
+		/*
+		D001654E 1040
+		8001654E 1000
+		skip mod check
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+    	*/
+  		add_D0_code(0x8001654E, common_routine_return_compare_val);
+  		add_80_code(0x8001654E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Gungauge
+   	((strcmp("SLPM_862.33", bootfile)) == 0) { // Japan
+		/*
+		D00E0206 1040
+		800E0206 1000
+		force ok
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+    	*/
+  		add_D0_code(0x800E0206, common_routine_return_compare_val);
+  		add_80_code(0x800E0206, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Harlem Beat: You're The One
+   	((strcmp("SLPM_863.29", bootfile)) == 0) { // Japan
+		/*
+		D01A411E 1040
+		801A411E 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x801A411E, common_routine_return_compare_val);
+  		add_80_code(0x801A411E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Hyper Value 2800: Hanafuda 
+   	((strcmp("SLPM_864.17", bootfile)) == 0) { // Japan
+		/*
+		D001844E 1440
+		8001844E 1040
+		my very first custom bypass developed in no $ psx emu! 
+		skips mod-check completely	
+		*/
+  		add_D0_code(0x8001844E, 0x1440);
+  		add_80_code(0x8001844E, common_routine_return_compare_val);	
+		install_cheat_engine();
+    } else if
+
+// Hyper Value 2800: Mahjong
+   	((strcmp("SLPM_862.92", bootfile)) == 0) { // Japan
+		/*
+		D00A0186 1040
+		800A0186 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x800A0186, common_routine_return_compare_val);
+  		add_80_code(0x800A0186, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Hyper Value 2800: Hyper Pachinko
+	((strcmp("SLPM_864.18", bootfile)) == 0) { // Japan
+		/*
+		D01380FE 1062
+		801380FE 1800
+		first match for PAL BIOS (there are 2 matches)
+		code generated via aprip
+    	*/
+  		add_D0_code(0x801380FE, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x801380FE, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// i-mode mo Issho: Doko Demo Issho Tsuika Disc
+    ((strcmp("SCPS_101.41", bootfile)) == 0) { // Japan
+	/*
+	D015205C 0062
+	8015205C 0014
+	D015205E 1202
+	8015205E 1800
+	aprip conversion from MottZilla and I's koneko mo isso bypass 
+	force ok for test commands
+	*/
+	add_D0_code(0x8015205C, 0x0062);
+	add_80_code(0x8015205C, 0x0014);
+	add_D0_code(0x8015205E, 0x1202);
+	add_80_code(0x8015205E, 0x1800);
+    /*
+    D01698B4 001E
+    801698B4 0000
+    code generated via aprip by M4x1mumReZ: https://gbatemp.net/members/m4x1mumrez.610331/
+    */
+    add_D0_code(0x801698B4, fake_vc0_bypass_compare_val);
+    add_80_code(0x801698B4, fake_vc0_bypass_patch_val);
+	/*
+	D01518D4 000A
+	801518D4 0000
+	D01518D6 1062
+	801518D6 0000
+	Fake a Non-PAL BIOS
+	aprip conversion from MottZilla and I's koneko mo isso bypass 
+	*/
+	add_D0_code(0x801518D4, 0x000A);
+	add_80_code(0x801518D4, 0x0000);
+	add_D0_code(0x801518D6, 0x1062);
+	add_80_code(0x801518D6, 0x0000);
+    install_cheat_engine();
+    } else if
+
+// I.Q Final
+	(
+	((strcmp("PCPX_961.37", bootfile)) == 0) // Japan Demo 1
+	|| ((strcmp("PAPX_900.63", bootfile)) == 0) // Japan Demo 2
+	) {
+		// Notice how the protection was not in the released retail version (this was supposed to be the second protected game after PoPoRoGue but the protection for PoPoRoGue Rev 0, the only protected game at the time, was broken for SCPH-1000 unmodified consoles): https://geocities.restorativland.org/SiliconValley/Station/8269/
+		/*
+		D00824CA 1040
+		800824CA 1000
+		force ok
+		code from https://consolecopyworld.com/psx/psx_game_codes_i.shtml
+    	*/
+  		add_D0_code(0x800824CA, common_routine_return_compare_val);
+  		add_80_code(0x800824CA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Jikkyou Powerful Pro Yakyuu: Premium-ban
+   	((strcmp("SLPM_872.16", bootfile)) == 0) { // Japan
+  		/*
+		D016641A 1040
+		8016641A 1000
+		my code via aprip conversion, I dumped the RAM from the Jikkyou Powerful Pro Yakyuu 2000: Ketteiban game and used the GameShark conversion feature with the dumped ram from Jikkyou Powerful Pro Yakyuu: Premium-ban and it actually was similar enough to work		
+		*/
+        add_D0_code(0x8016641A, common_routine_return_compare_val);
+        add_80_code(0x8016641A, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Jikkyou Powerful Pro Yakyuu '99 Ketteiban
+   	((strcmp("SLPM_864.33", bootfile)) == 0) { // Japan
+  		/*
+		D016A04E 1062
+		8016A04E 1800
+		my code via aprip
+		*/
+        add_D0_code(0x8016A04E, fake_pal_bios_bypass_compare_val);
+        add_80_code(0x8016A04E, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Jikkyou Powerful Pro Yakyuu '99: Kaimakuban
+   	((strcmp("SLPM_862.53", bootfile)) == 0) { // Japan
+		/*
+		D016A07A 1040
+		8016A07A 1000
+		code from copy console world: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+		*/
+        add_D0_code(0x8016A07A, common_routine_return_compare_val);
+        add_80_code(0x8016A07A, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Jikkyou Powerful Pro Yakyuu 2000: Kaimakuban / Jikkyou Powerful Pro Yakyuu 2000: Ketteiban
+	(
+   	((strcmp("SLPM_865.78", bootfile)) == 0) // Jikkyou Powerful Pro Yakyuu 2000: Kaimakuban
+	|| ((strcmp("SLPM_866.94", bootfile)) == 0) // Jikkyou Powerful Pro Yakyuu 2000: Ketteiban
+	) {
+		/*
+		D016807A 1040
+		8016807A 1000
+		my code via aprip conversion, I dumped the RAM from the Jikkyou Powerful Pro Yakyuu '99: Kaimakuban game and used the GameShark conversion feature with the dumped ram from Jikkyou Powerful Pro Yakyuu 2000: Ketteiban and it actually was similar enough to work
+		*/
+        add_D0_code(0x8016807A, common_routine_return_compare_val);
+        add_80_code(0x8016807A, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Jikkyou Powerful Pro Yakyuu 2001: Ketteiban / Jikkyou Powerful Pro Yakyuu 2001 / Jikkyou Powerful Pro Yakyuu 2002: Haru 
+	(
+   	((strcmp("SLPM_868.07", bootfile)) == 0) // Jikkyou Powerful Pro Yakyuu 2001
+   	|| ((strcmp("SLPM_869.90", bootfile)) == 0) // Jikkyou Powerful Pro Yakyuu 2001: Ketteiban
+	|| ((strcmp("SLPM_870.33", bootfile)) == 0) // Jikkyou Powerful Pro Yakyuu 2002: Haru
+	) {
+		/*
+		D01D9646 1040
+		801D9646 1000
+		my code via aprip conversion, I dumped the RAM from the Jikkyou Powerful Pro Yakyuu 2000: Ketteiban game and used the GameShark conversion feature with the dumped ram from Jikkyou Powerful Pro Yakyuu 2001: Ketteiban and it actually was similar enough to work. Code conversion got 2 matches, first match worked.
+		*/
+        add_D0_code(0x8016643A, common_routine_return_compare_val);
+        add_80_code(0x8016643A, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+	
+// Jikkyou Kyousouba Ikusei Simulation Game: Breeding Stud '99
+   	((strcmp("SLPM_863.16", bootfile)) == 0) { // Japan
+  		/*
+		D00A54D2 1040
+		800A54D2 1000
+		code from https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+		*/
+        add_D0_code(0x800A54D2, common_routine_return_compare_val);
+        add_80_code(0x800A54D2, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+// JoJo's Bizarre Adventure
+   	((strcmp("SLPS_022.36", bootfile)) == 0) { // Japan
+		/*
+		D0035C48 D91E
+		80035C48 D733
+		code 1 of 2 found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x80035C48, 0xD91E);
+  		add_80_code(0x80035C48, 0xD733);
+  		/*
+		D00360D2 1040
+		800360D2 1000
+		code 2 of 2 found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x800360D2, common_routine_return_compare_val);
+  		add_80_code(0x800360D2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Shiritsu Justice Gakuen: Nekketsu Seishun Nikki 2
+	((strcmp("SLPS_021.20", bootfile)) == 0) { // Japan
+		/*
+		D00A6CFA 1040
+		800A6CFA 1000
+		force ok
+		code from https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x800A6CFA, common_routine_return_compare_val);
+  		add_80_code(0x800A6CFA, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Koko Hore! Pukka
+	((strcmp("SCPS_101.33", bootfile)) == 0) { // Japan
+		/*
+		D008694A 1062
+		8008694A 1800
+		code generated via aprip
+    	*/
+  		add_D0_code(0x8008694A, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8008694A, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Koneko mo Issho
+   	((strcmp("SCPS_101.27", bootfile)) == 0) { // Japan
+		/*
+		D01520D8 0062
+		801520D8 0014
+		D01520DA 1202
+		801520DA 1800
+		bypass co-developed by me and MottZilla
+		force ok for test commands
+		*/	
+  		add_D0_code(0x801520D8, 0x0062);
+  		add_80_code(0x801520D8, 0x0014);
+  		add_D0_code(0x801520DA, 0x1202);
+  		add_80_code(0x801520DA, 0x1800);
+		/*
+		D016957C 001E
+		8016957C 0000
+		code generated via aprip to patch out readtoc
+    	*/
+  		add_D0_code(0x8016957C, fake_vc0_bypass_compare_val);
+  		add_80_code(0x8016957C, fake_vc0_bypass_patch_val);
+		/*
+		D0151950 000A
+		80151950 0000
+		D0151952 1062
+		80151952 0000
+		never lock up on PAL BIOS		
+		*/
+		add_D0_code(0x80151950, 0x000A);
+		add_80_code(0x80151950, 0x0000);
+		add_D0_code(0x80151952, 0x1062);
+		add_80_code(0x80151952, 0x0000);
+		install_cheat_engine();
+    } else if
+
+// Konami 80's Arcade Gallery
+	((strcmp("SLPM_862.28", bootfile)) == 0) { // Japan
+		/*
+		D0013FD2 1440
+		80013FD2 1000
+		skip mod check
+		code from https://consolecopyworld.com/psx/psx_game_codes_k.shtml
+    	*/
+  		add_D0_code(0x80013FD2, common_routine_return_compare_val);
+  		add_80_code(0x80013FD2, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Legend Of Dragoon
+   	(
+	((strcmp("SCPS_101.19", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("scps_101.20", bootfile)) == 0) // Japan Disc 2 (weird ass filename not a typo)
+	|| ((strcmp("scps_101.21", bootfile)) == 0) // Japan Disc 3 (weird ass filename not a typo)
+	|| ((strcmp("scps_101.22", bootfile)) == 0) // Japan Disc 4 (weird ass filename not a typo)
+	) {
+		/*
+		D01BF172 1040
+		801BF172 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+    	*/
+  		add_D0_code(0x801BF172, common_routine_return_compare_val);
+  		add_80_code(0x801BF172, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCUS_944.91", bootfile)) == 0) // USA Disc 1
+	|| ((strcmp("SCUS_945.84", bootfile)) == 0) // USA Disc 2
+	|| ((strcmp("SCUS_945.85", bootfile)) == 0) // USA Disc 3
+	|| ((strcmp("SCUS_945.86", bootfile)) == 0) // USA Disc 4
+	) {
+		/*
+		801BF6F6 1040
+		801BF6F6 1000 
+		my code via aprip's gameshark conversion
+   		*/
+  		add_D0_code(0x801BF6F6, common_routine_return_compare_val);
+  		add_80_code(0x801BF6F6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	(
+	(strcmp("SCES_030.43", bootfile)) == 0) // Europe Disc 1
+	|| ((strcmp("SCES_130.43", bootfile)) == 0) // Europe Disc 2
+	|| ((strcmp("SCES_230.43", bootfile)) == 0) // Europe Disc 3
+	|| ((strcmp("SCES_330.43", bootfile)) == 0) // Europe Disc 4
+	) {
+		/*
+		D01C0892 1040
+		801C0892 1000
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0892, common_routine_return_compare_val);
+  		add_80_code(0x801C0892, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCES_030.44", bootfile)) == 0) // France Disc 1
+	|| ((strcmp("SCES_130.44", bootfile)) == 0) // France Disc 2
+	|| ((strcmp("SCES_230.44", bootfile)) == 0) // France Disc 3
+	|| ((strcmp("SCES_330.44", bootfile)) == 0) // France Disc 4
+	) {
+		/*
+		D01C0872 1040
+		801C0872 1040
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0872, common_routine_return_compare_val);
+  		add_80_code(0x801C0872, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCES_030.45", bootfile)) == 0) // Germany Disc 1
+	|| ((strcmp("SCES_130.45", bootfile)) == 0) // Germany Disc 2
+	|| ((strcmp("SCES_230.45", bootfile)) == 0) // Germany Disc 3
+	|| ((strcmp("SCES_330.45", bootfile)) == 0)// Germany Disc 4
+	) { 
+		/*
+		D01C082E 1040
+		801C082E 1000
+		my code via aprip's gameshark conversion
+  		*/
+  		add_D0_code(0x801C082E, common_routine_return_compare_val);
+  		add_80_code(0x801C082E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCES_030.46", bootfile)) == 0) // Italian Disc 1
+	|| ((strcmp("SCES_130.46", bootfile)) == 0) // Italian Disc 2
+	|| ((strcmp("SCES_230.46", bootfile)) == 0) // Italian Disc 3
+	|| ((strcmp("SCES_330.46", bootfile)) == 0)// Italian Disc 4
+	) {
+		/*
+		D01C0826 1040
+		801C0826 1000
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0826, common_routine_return_compare_val);
+  		add_80_code(0x801C0826, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Legend Of Mana
+   	((strcmp("SLPS_021.70", bootfile)) == 0) { // Japan
+		/*
+		D0050ECA 1040 
+		80050ECA 1000
+		code 1 of 2 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+  		add_D0_code(0x80050ECA, common_routine_return_compare_val);
+  		add_80_code(0x80050ECA, common_routine_return_patch_val);
+    	/*
+		D00360D2 1040
+		800360D2 1000
+		code 2 of 2 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+  		add_D0_code(0x800360D2, common_routine_return_compare_val);
+  		add_80_code(0x800360D2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Lord Of Monsters
+   	((strcmp("SCPS_100.86", bootfile)) == 0) { // Japan
+  		/*
+		D0015F4A 1040
+		80015F4A 1000
+		force ok
+		code from https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+        add_D0_code(0x80015F4A, common_routine_return_compare_val);
+        add_80_code(0x80015F4A, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+   	((strcmp("PAPX_900.81", bootfile)) == 0) { // Japan Demo
+  		/*
+		D005E7EA 1040
+		8005E7EA 1000
+		force ok
+		code from aprip conversion
+		*/
+        add_D0_code(0x8005E7EA, common_routine_return_compare_val);
+        add_80_code(0x8005E7EA, common_routine_return_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Love Hina: Ai wa Kotoba no Naka ni / Love Hina 2: Kotoba wa Konayuki no You ni
+   	(
+	((strcmp("SLPM_866.52", bootfile)) == 0) // Love Hina: Ai wa Kotoba no Naka ni
+	|| ((strcmp("SLPM_866.77", bootfile)) == 0) // Love Hina 2: Kotoba wa Konayuki no You ni
+	) { 
+		/*
+		D01009FE 1620
+		801009FE 1220
+		custom bypass developed by myself with no $ psx emu
+		*/
+ 		add_D0_code(0x801009FE, 0x1620);
+ 		add_80_code(0x801009FE, 0x1220);
+ 		install_cheat_engine();
+    } else if
+
+// Magical Tetris Challenge featuring Mickey
+   	((strcmp("SLPS_017.86", bootfile)) == 0) {
+		/*
+		D014C072 1040
+		8014C072 1000
+		force ok
+		code from https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+		*/
+  		add_D0_code(0x8014C072, common_routine_return_compare_val);
+  		add_80_code(0x8014C072, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Marvel vs. Capcom: Clash of Super Heroes
+   	(
+	((strcmp("SLPS_023.68", bootfile)) == 0) // Japan
+	|| ((strcmp("SLPM_805.08", bootfile)) == 0) // Japan Demo
+	) {
+		/*
+		D00F0C3A 1040
+		800F0C3A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x800F0C3A, common_routine_return_compare_val);
+  		add_80_code(0x800F0C3A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Medievil II
+   	((strcmp("SCUS_945.64", bootfile)) == 0) {
+		/*
+		D009877E 1062
+		8009877E 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x8009877E, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8009877E, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Minna no Golf 2
+   	((strcmp("SCPS_100.93", bootfile)) == 0) { // Japan Rev 0 / Japan Rev 1
+		/*
+		D0050E3A 1040
+		80050E3A 1000
+		works on both Japan Rev 0 and Japan Rev 1
+		code from https://consolecopyworld.com/psx/psx_game_codes_e.shtml
+		*/
+  		add_D0_code(0x80050E3A, common_routine_return_compare_val);
+  		add_80_code(0x80050E3A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// MLB 2002 Demo, MLB 2002, MLB 2003 Demo, MLB 2003, MLB 2004, MLB 2005
+   	(
+	((strcmp("SCUS_946.48", bootfile)) == 0) // MLB 2002 USA Demo
+	|| ((strcmp("SCUS_946.38", bootfile)) == 0) // MLB 2002 USA
+	|| ((strcmp("SCUS_946.72", bootfile)) == 0) // MLB 2003 USA Demo
+	|| ((strcmp("SCUS_946.53", bootfile)) == 0) // MLB 2003 USA
+	|| ((strcmp("SCUS_946.89", bootfile)) == 0) // MLB 2004 USA
+	|| ((strcmp("SCUS_946.92", bootfile)) == 0) // MLB 2005 USA
+	) {
+		/*
+		D002024A 1062
+		8002024A 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x8002024A, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8002024A, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Metal Gear Solid: Integral
+	(
+   	((strcmp("SLPM_862.47", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SLPM_862.48", bootfile)) == 0) // // Japan Disc 2
+	) {
+		/*
+		D009E212 1040
+		8009E212 1000
+		skip mod check
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x8009E212, common_routine_return_compare_val);
+  		add_80_code(0x8009E212, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_862.49", bootfile)) == 0) { // Japan Disc 3
+		/*
+		D00C209A 1040
+		800C209A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x800C209A, common_routine_return_compare_val);
+  		add_80_code(0x800C209A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// My Garden
+   	((strcmp("SLPS_022.13", bootfile)) == 0) { // Japan
+		/*
+		D009E212 1040
+		8009E212 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x8009E212, common_routine_return_compare_val);
+  		add_80_code(0x8009E212, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2001 and NBA Shootout 2001 Demo
+   	((strcmp("SCUS_945.81", bootfile)) == 0) { // this game is nuts. Seriously what the fuck is this. The demo and retail versions share not only the same executable filename, the demo executable file is the exact same with 0 diffs compared to the retail version. I guess retail functionallity is being enabled by some other file in track 01 (which do in fact differ between the demo and retail versions). EVEN FUCKING WORSE is that the demo version has serial number SCUS_945.82, but the boot file is SCUS_945.81! For now we enable both demo and retail codes for both versions to ensure it boots, since we can't detect this off of bootfile alone. To do this in a less ugly way we would need to find the file in track 01 that differs (to enable retail functionallity) and then diff that in memory.
+		/*
+		D01AD562 1062
+		801AD562 1800
+		my code generated via aprip (USA)
+		*/
+		add_D0_code(0x801AD562, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801AD562, fake_pal_bios_bypass_patch_val);
+		/*
+		D01ABF9A 1062
+		801ABF9A 1800
+		my code generated via aprip (USA Demo)
+		*/
+		add_D0_code(0x801ABF9A, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801ABF9A, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2002
+   	((strcmp("SCUS_946.60", bootfile)) == 0) { // USA Demo
+		/*
+		D01AC5E6 1062
+		801AC5E6 1800
+		my code generated via aprip
+		*/
+		add_D0_code(0x801AC5E6, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801AC5E6, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_946.41", bootfile)) == 0) { // USA
+		/*
+		D01ADD06 1062
+		801ADD06 1800
+		my code generated via aprip
+		*/
+		add_D0_code(0x801ADD06, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801ADD06, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2003
+   	((strcmp("SCUS_946.73", bootfile)) == 0) { // USA
+		/*
+		D01ADE42 1062
+		801ADE42 1800
+		my code generated via aprip
+		*/
+		add_D0_code(0x801ADE42, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801ADE42, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2004
+   	((strcmp("SCUS_946.91", bootfile)) == 0) { // USA
+		/*
+		D01ADF0A 1062
+		801ADF0A 1800
+		my code generated via aprip
+		*/
+		add_D0_code(0x801ADF0A, fake_pal_bios_bypass_compare_val);
+		add_80_code(0x801ADF0A, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NCAA FinalFour 2001
+   	((strcmp("SCUS_945.79", bootfile)) == 0) { // USA
+		/*
+		D001DE06 1062
+		8001DE06 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x8001DE06, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8001DE06, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NCAA GameBreaker 2001
+   	(
+	((strcmp("SCUS_945.74", bootfile)) == 0) // USA
+	|| ((strcmp("SCUS_945.73", bootfile)) == 0) // USA Demo
+	) {
+		/*
+		D0100A5A 1062
+		80100A5A 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80100A5A, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80100A5A, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2001
+   	(
+	((strcmp("SCUS_945.75", bootfile)) == 0) // USA
+	|| ((strcmp("SCUS_945.76", bootfile)) == 0) // USA Demo
+	)
+	 {
+		/*
+		D010000E 1062
+		8010000E 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x8010000E, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8010000E, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2002, NFL GameDay 2003, NFL GameDay 2004, and NFL GameDay 2005
+   	(
+	((strcmp("SCUS_946.39", bootfile)) == 0) // NFL GameDay 2002 USA
+	|| ((strcmp("SCUS_946.65", bootfile)) == 0) // NFL GameDay 2003 USA
+	|| ((strcmp("SCUS_946.90", bootfile)) == 0) // NFL GameDay 2004 USA
+	|| ((strcmp("SCUS_946.95", bootfile)) == 0) // NFL GameDay 2005 USA
+	) {
+		/*
+		D002000E 1062
+		8002000E 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x8002000E, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8002000E, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NHL FaceOff 2001
+   	((strcmp("SCUS_945.77", bootfile)) == 0) { // USA
+		/*
+		D00F1126 1062
+		800F1126 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x800F1126, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x800F1126, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.78", bootfile)) == 0) { // USA Demo
+		/*
+		D00F05EE 1062
+		800F05EE 1800
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x800F05EE, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x800F05EE, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Oha-Studio Dance Dance Revolution
+   	((strcmp("SLPM_866.03", bootfile)) == 0) { // Japan
+		/*
+		D00F8236 1062
+		800F8236 1800
+		code generated via aprip
+    	*/
+  		add_D0_code(0x800F8236, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x800F8236, fake_pal_bios_bypass_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Omega Boost
+   	((strcmp("SCPS_100.20", bootfile)) == 0) { // Japan
+		/*
+		D0120876 1040
+		80120876 1000
+		force ok
+		code from https://consolecopyworld.com/psx/psx_game_codes_o.shtml
+    	*/
+  		add_D0_code(0x80120876, common_routine_return_compare_val);
+  		add_80_code(0x80120876, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("PAPX_900.80", bootfile)) == 0) { // Japan
+		/*
+		D0120876 1040
+		80120876 1000
+		force ok
+		code via aprip conversion (pattern length set to 10)
+    	*/
+  		add_D0_code(0x80120962, common_routine_return_compare_val);
+  		add_80_code(0x80120962, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Ore no Ryouri / My Cooking
+   	((strcmp("SCPS_100.99", bootfile)) == 0) { // Japan
+		/*
+		D0031C1A 1040
+		80031C1A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x80031C1A, common_routine_return_compare_val);
+  		add_80_code(0x80031C1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Ore no Shikabane o Koete Yuke
+   	((strcmp("SCPS_100.74", bootfile)) == 0) { // Japan
+		/*
+		D00C7DBE 1040
+		800C7DBE 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_o.shtml
+    	*/
+  		add_D0_code(0x800C7DBE, common_routine_return_compare_val);
+  		add_80_code(0x800C7DBE, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Panekit: Infinitive Crafting Toy Case
+// TODO: Find Japan Rev 1 and confirm the same code for Japan Rev 0 works
+   	((strcmp("SCPS_100.96", bootfile)) == 0) { // Japan Rev 0 / Japan Rev 1?
+		/*
+		skip mod check (3 codes)
+		D00F290C 800B
+		800F290E 1000
+		code 1/3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x800F290C, 0x800B);
+  		add_80_code(0x800F290E, common_routine_return_patch_val);
+		/*
+		D00F290C 800B
+		800F290C 000E
+		code 2/3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml		
+		*/
+  		add_D0_code(0x800F290C, 0x800B);
+  		add_80_code(0x800F290C, 0x000E);
+		/*
+		D0052710 FFF8
+		80052710 0001
+		code 3/3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x80052710, 0xFFF8);
+  		add_80_code(0x80052710, 0x0001);
+		install_cheat_engine();
+    } else if
+
+// Planet Lakia
+   	((strcmp("SLPM_862.64", bootfile)) == 0) { // Japan / English Translation
+		ver_check = (load_addr + 0xC130); // First different byte between original and translation. Translation has it's own bypass implemented which causes the game to lock up if ours is also applied.
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0x00)) { // Japan, English Translation has 0xC4 here
+			/*
+			D001F1C6 1402
+			8001F1C6 1000
+			force ok
+			code 1/2 from https://gamehacking.org/game/107982
+    		*/
+  			add_D0_code(0x8001F1C6, 0x1402);
+  			add_80_code(0x8001F1C6, common_routine_return_patch_val);
+			/*
+			D002DBA6 1040
+			8002DBA6 1000
+			code 2/2 from https://gamehacking.org/game/107982
+			*/
+  			add_D0_code(0x8002DBA6, common_routine_return_compare_val);
+  			add_80_code(0x8002DBA6, common_routine_return_patch_val);
+			install_cheat_engine();
+		}
+	} else if
+
+// Pocket Jiman
+   	((strcmp("SCPS_101.04", bootfile)) == 0) { // Japan
+		/*
+		D01054D2 1062
+		801054D2 1800
+		 code by https://gbatemp.net/members/m4x1mumrez.610331/ generated with APrip
+		*/
+  		add_D0_code(0x801054D2, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x801054D2, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pocket MuuMuu
+   	((strcmp("SCPS_100.76", bootfile)) == 0) { // Japan
+		/*
+		skip mod check
+		D001F7F8 2021
+		8001F7F4 FFF6
+		code 1/2 from https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x8001F7F8, 0x2021);
+  		add_80_code(0x8001F7F4, 0xFFF6);
+		/*
+		D001F7F8 2021
+		8001F7F6 1000
+		code 2/2 from https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x8001F7F8, 0x2021);
+  		add_80_code(0x8001F7F6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// PoPoLoCrois Monogatari II
+   	(
+	((strcmp("SCPS_101.12", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SCPS_101.13", bootfile)) == 0) // Japan Disc 2
+	|| ((strcmp("SCPS_101.14", bootfile)) == 0) // Japan Disc 3
+	) {
+		/*
+		 D00B2612 1040
+		 800B2612 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x800B2612, common_routine_return_compare_val);
+  		add_80_code(0x800B2612, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// PoPoRoGue
+   	((strcmp("SCPS_100.50", bootfile)) == 0) { // Japan Rev 0 / Japan Rev 1
+		ver_check = (load_addr + 0x8FC); // First different byte between rev 0 and rev 1.
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0x64)) { // Japan Rev 0
+			/*
+			D008EF4E 1040
+			8008EF4E 1000
+			code from https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+    		*/
+  			add_D0_code(0x8008EF4E, common_routine_return_compare_val);
+  			add_80_code(0x8008EF4E, common_routine_return_patch_val);
+			install_cheat_engine();
+		} else { // 0x7C Rev 1
+			/*
+			D012E96C 0119
+			8012E96C 0000
+			code 1/4 generated via aprip
+			*/
+  			add_D0_code(0x8012E96C, 0x0119);
+  			add_80_code(0x8012E96C, 0x0000);
+			/*
+			D012E96E 0304
+			8012E96E 0000
+			code 2/4 generated via aprip
+			*/
+  			add_D0_code(0x8012E96E, 0x0304);
+  			add_80_code(0x8012E96E, 0x0000);
+			/*
+			D012E978 0119
+			8012E978 0000
+			code 3/4 generated via aprip
+			*/
+  			add_D0_code(0x8012E978, 0x0119);
+  			add_80_code(0x8012E978, 0x0000);	
+			/*	
+			D012E97A 0302
+			8012E97A 0000
+			code 4/4 generated via aprip
+    		*/
+  			add_D0_code(0x8012E97A, 0x302);
+  			add_80_code(0x8012E97A, 0x0000);
+			install_cheat_engine();
+		}
+	} else if
+
+// Pop'n Music: Animation Melody
+   	((strcmp("SLPM_865.92", bootfile)) == 0) { // Japan
+		/*
+		D0016112 1062
+		80016112 1800
+		code generated via aprip
+    	*/
+  		add_D0_code(0x80016112, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80016112, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music: Disney Tunes
+   	((strcmp("SLPM_866.70", bootfile)) == 0) { // Japan
+		/*
+		D0013332 1062
+		80013332 1800
+		code generated via aprip
+    	*/
+  		add_D0_code(0x80013332, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80013332, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 2
+   	((strcmp("SLPM_862.94", bootfile)) == 0) { // Japan
+		/*
+		D0015342 1040
+		80015342 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+    	*/
+  		add_D0_code(0x80015342, common_routine_return_compare_val);
+  		add_80_code(0x80015342, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 5
+   	((strcmp("SLPM_869.37", bootfile)) == 0) { // Japan
+   		/*
+		D0030E0E 1062
+		80030E0E 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x80030E0E, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80030E0E, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 6
+   	((strcmp("SLPM_870.89", bootfile)) == 0) { // Japan
+		/*
+		D0030F06 1062
+		80030F06 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x80030F06, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80030F06, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Resident Evil 3: The Last Escape
+   	((strcmp("SLPS_023.00", bootfile)) == 0) { // Japan Rev 0/ Japan Rev 1
+		ver_check = (load_addr + 0x1B0); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0xF4)) // Rev 0
+		{
+			/*
+			D01840E2 1040
+			801840E2 1000
+			'skip check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+    		*/
+	    	add_D0_code(0x801840E2, common_routine_return_compare_val);
+			add_80_code(0x801840E2, common_routine_return_patch_val);
+    		install_cheat_engine();
+	    } else { // Rev 1
+			/*
+			D018418E 1040
+			8018418E 1000 
+			my code via aprip gameshark code conversion
+    		*/
+	    	add_D0_code(0x8018418E, common_routine_return_compare_val);
+			add_80_code(0x8018418E, common_routine_return_patch_val);
+    		install_cheat_engine();
+	    }
+	} else if
+
+   	((strcmp("SLPM_804.85", bootfile)) == 0) { // Japan Demo
+		/*
+		D01800E2 1040
+		801800E2 1000 
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x801800E2, common_routine_return_compare_val);
+		add_80_code(0x801800E2, common_routine_return_patch_val);
+    	install_cheat_engine();
+	} else if
+
+   	((strcmp("SLUS_900.64", bootfile)) == 0) { // USA Demo
+		/*
+		D01840E2 1040
+		801840E2 1000
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x801840E2, common_routine_return_compare_val);
+		add_80_code(0x801840E2, common_routine_return_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Resident Evil Survivor
+   	((strcmp("SLPS_025.53", bootfile)) == 0) { // Japan
+		/*
+		D0017962 1040
+		80017962 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+    	*/
+  		add_D0_code(0x80017962, common_routine_return_compare_val);
+  		add_80_code(0x80017962, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SLUS_010.87", bootfile)) == 0) { // USA
+		/*
+		D001714E 1040
+		8001714E 1000
+		converted code via aprip
+    	*/
+  		add_D0_code(0x8001714E, common_routine_return_compare_val);
+  		add_80_code(0x8001714E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SLES_027.32", bootfile)) == 0) // Europe
+	|| ((strcmp("SLES_027.44", bootfile)) == 0) // France
+	) {
+		/*
+		D001713E 1040
+		8001713E 1000
+		converted code via aprip
+    	*/
+  		add_D0_code(0x8001713E, common_routine_return_compare_val);
+  		add_80_code(0x8001713E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Robbit mon Dieu
+   	((strcmp("SCPS_101.03", bootfile)) == 0) { // Japan
+		/*
+		D001C646 1040
+		8001C646 1000
+		skip mod check
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8001C646, common_routine_return_compare_val);
+  		add_80_code(0x8001C646, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman
+   	((strcmp("SLPS_022.20", bootfile)) == 0) { // Japan
+		/*
+		D006C92A 1040
+		8006C92A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006C92A, common_routine_return_compare_val);
+  		add_80_code(0x8006C92A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 2: Dr. Wily no Nazo
+   	((strcmp("SLPS_022.55", bootfile)) == 0) { // Japan
+		/*
+		D006CA82 1040
+		8006CA82 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006CA82, common_routine_return_compare_val);
+  		add_80_code(0x8006CA82, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Rockman 3: Dr. Wily no Saigo!?
+   	((strcmp("SLPS_022.62", bootfile)) == 0) { // Japan
+		/*
+		D006CA1A 1040
+		8006CA1A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006CA1A, common_routine_return_compare_val);
+  		add_80_code(0x8006CA1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 4: Aratanaru Yabou!!
+   	((strcmp("SLPS_023.24", bootfile)) == 0) { // Japan
+		/*
+		D01D9E78 4042
+		801D9E78 0042 
+		force ok code
+		*/
+  		add_D0_code(0x801D9E78, 0x4042);
+  		add_80_code(0x801D9E78, 0x0042);
+	 	/*
+ 		D007009C 001E
+		8007009C 0000
+ 		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x8007009C, fake_vc0_bypass_compare_val);
+  		add_80_code(0x8007009C, fake_vc0_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 5: Blues no Wana!?
+   	((strcmp("SLPS_023.38", bootfile)) == 0) { // Japan
+		/*
+		D006E0D6 1062
+		8006E0D6 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x8006E0D6, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8006E0D6, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 6
+   	((strcmp("SLPS_023.79", bootfile)) == 0) { // Japan
+		/*
+		D006DA7A 1040
+		8006DA7A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006DA7A, common_routine_return_compare_val);
+  		add_80_code(0x8006DA7A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman X5
+   	((strcmp("SLPM_866.66", bootfile)) == 0) { // Japan
+		/*
+		D0011EC6 1062
+		80011EC6 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x80011EC6, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80011EC6, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman X6
+   	((strcmp("SLPM_869.59", bootfile)) == 0) { // Japan
+		/*
+		D001219E 1062
+		8001219E 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x8001219E, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x8001219E, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// SaGa Frontier II
+   	((strcmp("SLPS_019.90", bootfile)) == 0) { // Japan
+		/*
+		D00DC7D6 1040
+		800DC7D6 1000
+		force ok test commands
+		code from https://consolecopyworld.com/psx/psx_game_codes_s.shtml		
+		*/
+  		add_D0_code(0x800DC7D6, common_routine_return_compare_val);
+  		add_80_code(0x800DC7D6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Saru! Get You! / Ape Escape
+   	((strcmp("SCPS_100.91", bootfile)) == 0) { // Japan Rev 0
+		ver_check = (load_addr + 0x68); // First different byte between revisions is 0x68
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if(ver_check_val == 0xA0) { // Rev 0
+		/*
+		D0136A8A 1040
+		80136A8A 1000
+		force ok test commands
+		code from https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+		*/
+  		add_D0_code(0x80136A8A, common_routine_return_compare_val);
+  		add_80_code(0x80136A8A, common_routine_return_patch_val);
+		} else { // 0xF0 Japan Rev 1
+		/*
+		D0136AAA 1040
+		80136AAA 1000
+		force ok test commands
+		my code via aprip conversion
+		*/
+  		add_D0_code(0x80136AAA, common_routine_return_compare_val);
+  		add_80_code(0x80136AAA, common_routine_return_patch_val);			
+		}
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("PAPX_900.79", bootfile)) == 0) { // Japan demo
+		/*
+		D0137A2A 1040
+		80137A2A 1000
+		force ok test commands
+		my code via aprip conversion		
+		*/
+  		add_D0_code(0x80137A2A, common_routine_return_compare_val);
+  		add_80_code(0x80137A2A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Silent Hill
+// TODO: Find Japan Rev 2 to confirm it also works
+   	((strcmp("SLPM_861.92", bootfile)) == 0) { // Japan Rev 0/Japan Rev 1
+		// same code works for both Japan Rev 0 and Japan Rev 1
+		/*
+		D01E778E 1040
+		801E778E 1000
+		my code via aprip gameshark code conversion
+		*/
+  		add_D0_code(0x801E778E, common_routine_return_compare_val);
+  		add_80_code(0x801E778E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Spyro The Dragon
+   	(
+	((strcmp("SCPS_100.85", bootfile)) == 0) // Japan
+	|| ((strcmp("SCPS_100.83", bootfile)) == 0)
+	) {
+		/*
+		D006003E 9222
+		8006003E A222
+		skip mod check
+		codes from https://consolecopyworld.com/psx/psx_game_codes_s.shtml
+		*/
+  		add_D0_code(0x8006003E, 0x9222);
+  		add_80_code(0x8006003E, 0xA222);
+		install_cheat_engine();
+    } else if
+
+// Spyro: Year Of The Dragon
+	((strcmp("SCUS_944.67", bootfile)) == 0) { // has 2 versions, rev 0 and rev 1
+		ver_check = (load_addr); // First different byte between revisions is well the first byte :)
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if(ver_check_val == 0xF4) { // Rev 0
+			/*
+			D007F08C 0001
+			8007F08C 0000
+			D007F08C 0002
+			8007F08C 0000
+			D007F08C 0003
+			8007F08C 0000
+			D007F08C 0004
+			8007F08C 0000
+			D007F08C 0005
+			8007F08C 0000
+			D007F08C 0006
+			8007F08C 0000
+			D007F08C 0007
+			8007F08C 0000
+			D007F08C 0008
+			8007F08C 0000
+			D007F08C 0009
+			8007F08C 0000
+			D007F08C 000A
+			8007F08C 0000
+			D007F08C 000B
+			8007F08C 0000
+			D007F08C 000C
+			8007F08C 0000
+			D007F08C 000D
+			8007F08C 0000
+			D007F08C 000E
+			8007F08C 0000
+			codes co-developed by MottZilla (mostly) and myself.	
+			*/
+			add_D0_code(0x8007F08C, 0x0001);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0002);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0003);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0004);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0005);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0006);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0007);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0008);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0009);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000A);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000B);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000C);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000D);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000E);
+			add_80_code(0x8007F08C, 0x0000);
+			install_cheat_engine();
+		} else { // 0x08 = Rev 1
+			/*
+			D007F23C 0001
+			8007F23C 0000
+			D007F23C 0002
+			8007F23C 0000
+			D007F23C 0003
+			8007F23C 0000
+			D007F23C 0004
+			8007F23C 0000
+			D007F23C 0005
+			8007F23C 0000
+			D007F23C 0006
+			8007F23C 0000
+			D007F23C 0007
+			8007F23C 0000
+			D007F23C 0008
+			8007F23C 0000
+			D007F23C 0009
+			8007F23C 0000
+			D007F23C 000A
+			8007F23C 0000
+			D007F23C 000B
+			8007F23C 0000
+			D007F23C 000C
+			8007F23C 0000
+			D007F23C 000D
+			8007F23C 0000
+			D007F23C 000E
+			8007F23C 0000
+			Codes manually converted to Rev 1 by myself	
+			*/
+			add_D0_code(0x8007F23C, 0x0001);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0002);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0003);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0004);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0005);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0006);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0007);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0008);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0009);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000A);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000B);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000C);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000D);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000E);
+			add_80_code(0x8007F23C, 0x0000);
+			install_cheat_engine();
+    	}
+	} else if
+
+// Street Fighter EX2 Plus
+   	((strcmp("SLPS_025.08", bootfile)) == 0) { // Japan
+		/*
+		D01BD48A 1040
+		801BD48A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_s.shtml
+		*/
+  		add_D0_code(0x801BD48A, common_routine_return_compare_val);
+  		add_80_code(0x801BD48A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_805.17", bootfile)) == 0) { // Japan Demo
+		/*
+		D01BD13E 1040
+		801BD13E 1000
+		my code via aprip gameshark code conversion
+		*/
+  		add_D0_code(0x801BD48A, common_routine_return_compare_val);
+  		add_80_code(0x801BD13E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Strider 2
+   	((strcmp("SLUS_011.63", bootfile)) == 0) { // USA
+		/*
+		D01F4D5E 1062
+		801F4D5E 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x801F4D5E, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x801F4D5E, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tokimeki Memorial 2 (soo many god damn discs/versions/bootfiles)
+   	(
+	// main game (5 discs)
+	   ((strcmp("SLPM_863.55", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 1
+	|| ((strcmp("SLPM_863.50", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 1
+	|| ((strcmp("SLPM_863.56", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 2
+	|| ((strcmp("SLPM_863.51", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 2
+	|| ((strcmp("SLPM_863.57", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 3
+	|| ((strcmp("SLPM_863.52", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 3
+	|| ((strcmp("SLPM_863.58", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 4
+	|| ((strcmp("SLPM_863.53", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 4
+	|| ((strcmp("SLPM_863.59", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 5
+	|| ((strcmp("SLPM_863.54", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 5
+	// dlc evs (3 discs)
+	|| ((strcmp("SLPM_805.27", bootfile)) == 0) // Tokimeki Memorial 2 Emotional Voice System Append Disc 1
+	|| ((strcmp("SLPM_805.44", bootfile)) == 0) // Tokimeki Memorial 2 Emotional Voice System Append Disc 2
+	|| ((strcmp("SLPM_805.50", bootfile)) == 0) // Tokimeki Memorial 2 Emotional Voice System Append Disc 3
+	) {
+		/*
+		D00108C6 1040
+		800108C6 1000
+		code from https://gamehacking.org/game/109315
+		force ok result of test commands
+		*/
+  		add_D0_code(0x800108C6, common_routine_return_compare_val);
+  		add_80_code(0x800108C6, common_routine_return_patch_val);
+		/*
+		D0011514 001E
+		80011514 0000
+		my code via aprip to disable readtoc
+		*/
+  		add_D0_code(0x80011514, fake_vc0_bypass_compare_val);
+  		add_80_code(0x80011514, fake_vc0_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tokimeki Memorial Drama Series Vol. 3: Tabidachi no Uta
+   	(
+	((strcmp("SLPM_862.24", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SLPM_862.25", bootfile)) == 0) // Japan Disc 2
+	){ // Japan Disc 1
+		/*
+		D005C290 2021
+		8005C28C FFF6
+		code 1/3 from https://consolecopyworld.com/psx/psx_game_codes_t.shtml
+		*/
+  		add_D0_code(0x8005C290, 0x2021);
+  		add_80_code(0x8005C28C, 0xFFF6);
+		/*
+		D005C290 2021
+		8005C28E 1000
+		code 2/3 from https://consolecopyworld.com/psx/psx_game_codes_t.shtml
+		*/
+  		add_D0_code(0x8005C290, 0x2021);
+  		add_80_code(0x8005C28E, common_routine_return_patch_val);
+		/*
+		D001B3A6 1060
+		8001B3A6 1000
+		code 3/3 from https://consolecopyworld.com/psx/psx_game_codes_t.shtml
+		*/
+  		add_D0_code(0x8001B3A6, 0x1060);
+  		add_80_code(0x8001B3A6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tomba! 2: The Evil Swine Return
+   	((strcmp("SCUS_944.54", bootfile)) == 0) { // USA
+		/*
+		D0011A1A 1062
+		80011A1A 1800
+		my code via aprip
+		*/
+  		add_D0_code(0x80011A1A, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x80011A1A, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tron ni Kobun
+   	((strcmp("SLPS_021.08", bootfile)) == 0) {  // Japan
+		/*
+		D001277A 1040
+		8001277A 1000
+		code from https://gamehacking.org/game/109452
+		force ok test command results
+		*/
+  		add_D0_code(0x8001277A, common_routine_return_compare_val);
+  		add_80_code(0x8001277A, common_routine_return_patch_val);
+		/*
+		D004E168 001E
+		8004E168 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x8004E168, fake_vc0_bypass_compare_val);
+  		add_80_code(0x8004E168, fake_vc0_bypass_patch_val);
+		// together these commands disable the routine effectively
+		install_cheat_engine();
+    } else if
+
+// Um Jammer Lammy
+// TODO: FIND Um Jammer Lammy Japan Tentou Houei-you and add support if needed
+   	((strcmp("SCPS_180.11", bootfile)) == 0) { // Japan
+ 		/*	
+		D01DA7D8 2021
+		801DA7D4 FFF6
+		code 1/2 from https://consolecopyworld.com/psx/psx_game_codes_u.shtml
+  		*/
+		add_D0_code(0x801DA7D8, 0x2021);
+  		add_80_code(0x801DA7D4, 0xFFF6);
+		/*
+		D01DA7D8 2021
+		801DA7D6 1000
+		code 2/2 from https://consolecopyworld.com/psx/psx_game_codes_u.shtml
+		*/
+  		add_D0_code(0x801DA7D8, 0x2021);
+  		add_80_code(0x801DA7D6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Vandal Hearts II
+   	((strcmp("SLUS_009.40", bootfile)) == 0) { // USA
+ 		/*	
+    	D0040C90 000B
+    	80040C92 1000 
+		code from http://archive.thegia.com/news/9912/n09a.html
+		*/
+  		add_D0_code(0x80040C90, 0x000B);
+  		add_80_code(0x80040C92, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_862.51", bootfile)) == 0) { // Japan
+ 		/*	
+    	D00C49A2 1040
+		800C49A2 1000
+		code from https://consolecopyworld.com/psx/psx_game_codes_v.shtml
+		*/
+  		add_D0_code(0x800C49A2, common_routine_return_compare_val);
+  		add_80_code(0x800C49A2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Wild Arms 2
+   	(
+	((strcmp("SCUS_944.84", bootfile)) == 0) // USA Disc 1
+	|| ((strcmp("SCUS_944.98", bootfile)) == 0) // USA Disc 2
+	) {
+   		/*
+   		D00282CE 1062
+		800282CE 1800
+ 		my code via aprip to patch out readtoc
+    	*/
+  		add_D0_code(0x800282CE, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x800282CE, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.92", bootfile)) == 0) { // USA Demo
+		/*
+   		D00283C6 1062
+		800283C6 1800
+		my code via aprip gameshark code conversion on my own code (code-ception)
+    	*/
+  		add_D0_code(0x800283C6, fake_pal_bios_bypass_compare_val);
+  		add_80_code(0x800283C6, fake_pal_bios_bypass_patch_val);
+		install_cheat_engine();
+    } else if
+
+// World Soccer Jikkyou Winning Eleven 4
+   	((strcmp("SLPM_862.91", bootfile)) == 0) { // Japan Rev 0/Japan Rev 1
+		/*
+   		D01030CA 1040
+		801030CA 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_w.shtml
+    	*/
+  		add_D0_code(0x801030CA, common_routine_return_compare_val);
+  		add_80_code(0x801030CA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// XI[SAI] Jumbo
+   	((strcmp("SCPS_101.23", bootfile)) == 0) { // Japan
+	   	/*
+   		D010178A 1040
+		8010178A 1000
+		code 1 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x8010178A, common_routine_return_compare_val);
+  		add_80_code(0x8010178A, common_routine_return_patch_val);
+ 		/*
+		D00A370A 1040
+		800A370A 1000
+		code 2 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x800A370A, common_routine_return_compare_val);
+  		add_80_code(0x800A370A, common_routine_return_patch_val);
+ 		/*
+		D0113C1A 1040
+		80113C1A 1000
+		code 3 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x80113C1A, common_routine_return_compare_val);
+  		add_80_code(0x80113C1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Yu-Gi-Oh! Forbidden Memories
+   	(
+	((strcmp("SLPM_863.96", bootfile)) == 0) // Japan
+	|| ((strcmp("SLPM_863.98", bootfile)) == 0) // Japan Demo
+	|| ((strcmp("SLUS_014.11", bootfile)) == 0) // USA
+	|| ((strcmp("SLES_039.47", bootfile)) == 0) // Europe
+	|| ((strcmp("SLES_039.48", bootfile)) == 0) // France
+	|| ((strcmp("SLES_039.49", bootfile)) == 0) // Germany
+	|| ((strcmp("SLES_039.50", bootfile)) == 0) // Spain
+	|| ((strcmp("SLES_039.51", bootfile)) == 0) // Italy
+	) {
+		/*
+		D016818A 1040
+		8016818A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_y.shtml
+    	*/
+  		add_D0_code(0x8016818A, common_routine_return_compare_val);
+  		add_80_code(0x8016818A, common_routine_return_patch_val);
+		install_cheat_engine();
+    }
+}
\ No newline at end of file
diff --git a/loader/ap-bypass.h b/loader/ap-bypass.h
new file mode 100644
index 0000000..0ea5553
--- /dev/null
+++ b/loader/ap-bypass.h
@@ -0,0 +1,9 @@
+
+#pragma once
+
+void activate_anti_anti_piracy(char * bootfile, const int32_t load_addr);
+void add_8bit_code(const uint32_t gs1, const uint8_t gs2, const uint8_t gs_code_type);
+void add_16bit_code(const uint32_t gs1, const uint16_t gs2, const uint8_t gs_code_type);
+void install_cheat_engine();
+
+extern bool cheat_engine_installed;
diff --git a/tmp/og-tonyhax.0JX/loader/bios-asm.S b/loader/bios-asm.S
index f181105..a71573d 100644
--- a/tmp/og-tonyhax.0JX/loader/bios-asm.S
+++ b/loader/bios-asm.S
@@ -69,11 +69,6 @@ memcpy:
 	li t1, 0x2A
 	j 0xA0
 
-.global std_out_puts
-std_out_puts:
-	li t1, 0x3E
-	j 0xA0
-
 .global DoExecute
 DoExecute:
 	# Pepsiman (J) crashes if s5 is not zero
@@ -132,16 +127,16 @@ SetConf:
 	li t1, 0x9C
 	j 0xA0
 
-.global SetMemSize
-SetMemSize:
-	li t1, 0x9F
-	j 0xA0
-
 .global CdReadSector
 CdReadSector:
 	li t1, 0xA5
 	j 0xA0
 
+.global SetMemSize
+SetMemSize:
+	li t1, 0x9F
+	j 0xA0
+
 ###############
 # B-FUNCTIONS #
 ###############
diff --git a/tmp/og-tonyhax.0JX/loader/bios.c b/loader/bios.c
index 92edfab..13af146 100644
--- a/tmp/og-tonyhax.0JX/loader/bios.c
+++ b/loader/bios.c
@@ -5,23 +5,13 @@
 #include "debugscreen.h"
 #include "str.h"
 
-void * original_disc_error;
-
-bool console_has_tty() {
-	/*
-	 * Check if the console has a SCN2681 TTY used for debug by writing data to the control
-	 * registers and reading it back.
-	 *
-	 * The control is 16 bit wide, and is accessed by writing or reading twice the same register.
-	 */
-	volatile uint8_t * scn2681modereg = (uint8_t *) 0x1F802020;
+// Set to zero unless you are using an emulator or have a physical UART on the PS1, else it'll freeze
+const uint32_t tty_enabled = 0;
 
-	*scn2681modereg = 0x55;
-	*scn2681modereg = 0xAA;
-	return *scn2681modereg == 0x55 && *scn2681modereg == 0xAA;
-}
+void * original_disc_error;
 
 void bios_reinitialize() {
+	// See https://github.com/ogamespec/psxdev/blob/master/reverse/Main.c for reference to some of this...
 	// Disable interrupts
 	EnterCriticalSection();
 
@@ -52,8 +42,8 @@ void bios_reinitialize() {
 	I_STAT = 0;
 	I_MASK = 0;
 
-	// Setup devices.
-	InstallDevices(console_has_tty());
+	// Setup devices
+	InstallDevices(tty_enabled);
 
 	/*
 	 * Configure with default values
@@ -94,12 +84,12 @@ void bios_reinitialize() {
 	/*
 	 * Set RAM size to 8MB, which is incorrect but it's what the BIOS sets.
 	 *
-	 * This is required because the entrypoint game might've set it to 2MB, and a bugged target
-	 * game might accidentally access an address in the mirror region, causing a fault to be caused
+	 * This is required because the entrypoint game might've set it to 2MB, and a target
+	 * game might accidentally access an address in the mirror region (expecting the default 8MB setting from BIOS boot), causing a fault to be caused
 	 * in real hardware.
 	 */
 	SetMemSize(8);
-
+	
 	// Re-enable interrupts
 	ExitCriticalSection();
 
diff --git a/tmp/og-tonyhax.0JX/loader/bios.h b/loader/bios.h
index bb6515c..6aa00ce 100644
--- a/tmp/og-tonyhax.0JX/loader/bios.h
+++ b/loader/bios.h
@@ -219,13 +219,6 @@ void ExitCriticalSection();
  */
 uint32_t todigit(char c);
 
-/**
- * Prints a text through the TTY.
- *
- * @param text text to print
- */
-void std_out_puts(const char * text);
-
 /**
  * Starts a previously loaded executable.
  *
@@ -326,15 +319,6 @@ bool CdInit(void);
  */
 void SetConf(uint32_t evcb, uint32_t tcb, uint32_t stacktop);
 
-/**
- * Configured the RAM size.
- *
- * @param size memory size in megabytes, either 2 or 8.
- *
- * Table A, call 0x9F.
- */
-void SetMemSize(uint32_t size);
-
 /**
  * Reads the requested amount of sectors from the CD.
  *
@@ -448,3 +432,10 @@ void InstallDevices(uint32_t enable_tty);
  * Table C, call 0x1C.
  */
 void AdjustA0Table(void);
+
+/**
+ * Called to set the RAM to 8MBs, which enables the mirroring of RAM 4 times in the real 2MBs of RAM (which is exactly what the BIOS ends up doing)
+ *
+ * Table A, call 0x9F.
+ */
+void SetMemSize(uint32_t mem_size);
diff --git a/tmp/og-tonyhax.0JX/loader/cdrom.c b/loader/cdrom.c
index dddc533..40d9b6f 100644
--- a/tmp/og-tonyhax.0JX/loader/cdrom.c
+++ b/loader/cdrom.c
@@ -43,6 +43,40 @@ void cd_command(uint_fast8_t cmd, const uint8_t * params, uint_fast8_t params_le
 	CD_REGS[1] = cmd;
 }
 
+void cd_command_race(uint_fast8_t cmd, const uint8_t * params, uint_fast8_t params_len) {
+
+	// Wait for previous command to finish, if any
+	//while (CD_REGS[0] & 0x80);
+
+	// Switch to page 0
+	cd_set_page(0);
+
+	// Clear read and write FIFOs
+	CD_REGS[3] = 0xC0;
+
+	// Copy request
+	while (params_len != 0) {
+		CD_REGS[2] = *params;
+		params++;
+		params_len--;
+	}
+
+	// Switch to page 1
+	cd_set_page(1);
+
+	// Disable interrupts as we'll poll
+	CD_REGS[2] = 0x00;
+
+	// Acknowledge interrupts, if there were any
+	CD_REGS[3] = 0x07;
+
+	// Switch to page 0
+	cd_set_page(0);
+
+	// Finally write command to start
+	CD_REGS[1] = cmd;
+}
+
 uint_fast8_t cd_wait_int(void) {
 
 	// Wait for command to finish, if any
@@ -64,6 +98,28 @@ uint_fast8_t cd_wait_int(void) {
 	return interrupt;
 }
 
+uint_fast8_t cd_wait_int_race(void) {
+
+	// Wait for command to finish, if any
+	//while (CD_REGS[0] & 0x80);
+
+	// Switch to page 1
+	cd_set_page(1);
+
+	// Wait until an interrupt happens (int != 0)
+	uint_fast8_t interrupt;
+	do {
+		interrupt = CD_REGS[3] & 0x07;
+	} while (interrupt == 0);
+
+	// Acknowledge it
+	CD_REGS[3] = 0x07;
+
+	// Return it
+	return interrupt;
+}
+
+
 uint_fast8_t cd_read_reply(uint8_t * reply_buffer) {
 
 	// Switch to page 1
@@ -81,6 +137,9 @@ uint_fast8_t cd_read_reply(uint8_t * reply_buffer) {
 	return len;
 }
 
+//we can't trust this due to a race condition. If the actual BIOS executes a CD command (affects the Tonyhax International ROM), or a game is in the middle of executing a CD command when Tonyhax International starts (affects GSHAX), and this is executed close enough in the Tonyhax International loader code itself, it will get stuck if done like below:
+
+/*
 bool cd_drive_init() {
 	cd_command(CD_CMD_INIT, NULL, 0);
 
@@ -96,18 +155,22 @@ bool cd_drive_init() {
 
 	return true;
 }
+*/
 
-bool cd_drive_reset() {
-	// Issue a reset
+void cd_drive_init() {
+	cd_command_race(CD_CMD_INIT, NULL, 0);
+
+	cd_wait_int_race();
+	cd_wait_int_race();
+}
+
+void cd_drive_reset() {
+	// Issue a reset (looses authentication and or unlock when completed, so do an unlock after this)
 	cd_command(CD_CMD_RESET, NULL, 0);
 
-	// Should succeed with 3
-	if (cd_wait_int() != 3) {
-		return false;
-	}
+	// Should succeed with 3 but doesn't sometimes so we can't check the return value
+	cd_wait_int();
 
 	// Need to wait for some cycles before it springs back to life
-	for (int i = 0; i < 0x400000; i++);
-
-	return true;
+	for (volatile int i = 0; i < 0x400000; i++); // unmodifiable compiler code when using -Os optimizations
 }
diff --git a/tmp/og-tonyhax.0JX/loader/cdrom.h b/loader/cdrom.h
index 438e7cd..c26874d 100644
--- a/tmp/og-tonyhax.0JX/loader/cdrom.h
+++ b/loader/cdrom.h
@@ -8,6 +8,12 @@
 #define CD_CMD_TEST 0x19
 #define CD_CMD_RESET 0x1C
 #define CD_TEST_REGION 0x22
+#define CD_CMD_SET_SESSION 0x12
+#define CD_CMD_STOP 0x08
+#define CD_CMD_GETID 0x1A
+#define CD_CMD_SETMODE 0x0E
+#define CD_CMD_GETTN 0x13
+#define CD_CMD_GETTD 0x14
 
 /**
  * Starts executing a CD command.
@@ -38,11 +44,9 @@ uint_fast8_t cd_read_reply(uint8_t * reply_buffer);
  *
  * @returns true if succeded, or false otherwise.
  */
-bool cd_drive_init(void);
+//bool cd_drive_init(void);
+// we can't trust that:
+void cd_drive_init();
 
-/**
- * Resets the drive.
- *
- * @returns true if succeded, or false otherwise.
- */
-bool cd_drive_reset(void);
+// Resets the drive.
+void cd_drive_reset();
diff --git a/tmp/og-tonyhax.0JX/loader/debugscreen.c b/loader/debugscreen.c
index cb8c32e..926cb0c 100644
--- a/tmp/og-tonyhax.0JX/loader/debugscreen.c
+++ b/loader/debugscreen.c
@@ -113,7 +113,7 @@ void debug_init() {
 	gpu_flush_cache();
 
 	// Draw border
-	debug_text_at(TH_MARGIN, 40, "tonyhax " STRINGIFY(TONYHAX_VERSION));
+	debug_text_at(TH_MARGIN, 40, "tonyhax international " STRINGIFY(TONYHAX_VERSION));
 	struct gpu_solid_rect band = {
 		.pos = {
 			.x = 0,
@@ -237,9 +237,12 @@ void debug_write(const char * str, ...) {
 	} else {
 		last_printed_count++;
 
-		// Same line, so print with a repeat counter
-		mini_sprintf(formatted_repeated, "%s (x%d)", last_printed_line, last_printed_count);
-
+		// Same line, so print with a repeat counter unless we are waiting for controller input on a Japanese console
+		if(!controller_input) {
+			mini_sprintf(formatted_repeated, "%s (x%d)", last_printed_line, last_printed_count);
+		} else {
+			mini_sprintf(formatted_repeated, "%s", last_printed_line);
+		}
 		to_print = formatted_repeated;
 	}
 
diff --git a/tmp/og-tonyhax.0JX/loader/debugscreen.h b/loader/debugscreen.h
index 6ae71a5..d06a360 100644
--- a/tmp/og-tonyhax.0JX/loader/debugscreen.h
+++ b/loader/debugscreen.h
@@ -10,3 +10,5 @@ void debug_write(const char * str, ...);
 void debug_text_at(uint_fast16_t x, uint_fast16_t y, const char * str);
 
 void debug_switch_standard(bool pal);
+
+extern bool controller_input;
\ No newline at end of file
diff --git a/tmp/og-tonyhax.0JX/loader/generate-tonyhax-mcs.sh b/loader/generate-tonyhax-mcs.sh
index 33116fa..b01a8b9 100644
--- a/tmp/og-tonyhax.0JX/loader/generate-tonyhax-mcs.sh
+++ b/loader/generate-tonyhax-mcs.sh
@@ -25,11 +25,11 @@ load_len=$(printf "%08X" $(stat -c %s $bin_file))
 
 # Create file
 cp "$tpl_file" "$mcs_file"
-echo -n "tonyhax ${version}" | dd status=none conv=notrunc bs=1 seek=132 of="$mcs_file"
+echo -n "tonyhax-i ${version}" | dd status=none conv=notrunc bs=1 seek=132 of="$mcs_file"
 dd status=none conv=notrunc bs=1 seek=384 if=$bin_file of="$mcs_file"
 
 # Insert address at 0xC0 and length at 0xC4, which is 0x40 and 0x44 inside the save file header
-echo -ne "\x${ro_start:6:2}\x${ro_start:4:2}\x${ro_start:2:2}\x${ro_start:0:2}\x${load_len:6:2}\x${load_len:4:2}\x${load_len:2:2}\x${load_len:0:2}" | dd status=none conv=notrunc of=tonyhax.mcs bs=1 seek=192
+echo -ne "\x${ro_start:6:2}\x${ro_start:4:2}\x${ro_start:2:2}\x${ro_start:0:2}\x${load_len:6:2}\x${load_len:4:2}\x${load_len:2:2}\x${load_len:0:2}" | dd status=none conv=notrunc of="$mcs_file" bs=1 seek=192
 
 # Cleanup
 rm $bin_file
diff --git a/tmp/og-tonyhax.0JX/loader/patch-ap.S b/tmp/og-tonyhax.0JX/loader/patch-ap.S
deleted file mode 100644
index 85511eb..0000000
--- a/tmp/og-tonyhax.0JX/loader/patch-ap.S
+++ /dev/null
@@ -1,196 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# Intercepts the syscall(1) (aka EnterCriticalSection).
-#
-# When this code is executed, the registers are as follows:
-#   - v0: saved thread registers, must NOT be modified.
-# The rest of the registers are not critical and can be used freely.
-#
-.globl patch_ap_start
-patch_ap_start:
-	# Load the SP value
-	lw t0, 0x7C(v0)
-
-	#
-	# If we are being called from an antimodchip module, the call stack will look like this:
-	#  - (game code)
-	#  - ap_check
-	#  - ap_failed
-	#  - StopCallback
-	#  - disable_ints
-	#  - EnterCriticalSection
-	#
-	# For all known modules, the return address from StopCallback to ap_failed sits at SP+0x28.
-	#
-	# Before reading from this address, we will check that after adding that offset, we do not
-	# cross a 2MB boundary, which could cause an illegal memory read.
-	#
-	# Without this check the following games crash:
-	#  - Elemental Gearbolt (U) (SLUS-00654), calling with a stack at 0x807FFFE0, as we attempt
-	#    to read from 0x80800008.
-	#  - Rival Schools (U) (SLUS-00681), calling with a stack of 0x801FFFD8, as we attempt to
-	#    read from 0x80200000. A mirror would be generally present here, but not for this game
-	#    as it calls SetMemSize(2) to intentionally block this.
-	#
-	# Some games, like Grind Session (U) (SCUS-94568) use the scratchpad during gameplay for the
-	# stack, which is only 1KB. For now, we will not add a safety check for this case since the
-	# vast majority of games store the stack in RAM and no game is known to crash without it.
-	#
-	addi t1, t0, 0x28
-	xor t1, t0
-	srl t1, 21
-	bne t1, zero, patch_ap_skip
-
-	# Load alledged return address
-	lw t1, 0x28(t0)
-
-	#
-	# Check now if the loaded value could be a word-aligned address in either the KUSEG
-	# (0x00000000-0x007FFFFF) or the KSEG0 (0x80000000-0x807FFFFF) regions, which is were user
-	# code is executed.
-	#
-	# Most games use the KSEG0, except for Emperors New Groove (U) (SCUS-94571) whose programmers
-	# seemed to prefer the KUSEG region.
-	#
-	# We cannot limit ourselves to checking the first 2MB of RAM, because some games, like
-	# Robbit Mon Dieu (J) (SCPS-10103) use a mirror (0x80600000-0x807FFFFF).
-	#
-	li t2, 0x7F800003
-	and t2, t1
-	bne t2, zero, patch_ap_skip
-
-	#
-	# First, we will attempt to handle a version 1 antimodchip module.
-	#
-	# This checks only for the presence of a dumb modchip, by checking if the SCEx counter
-	# increments when it should not. It is also only capable of displaying the stop screen
-	# in Japanese.
-	#
-	# The offsets for some of the checked games are:
-	#
-	# Um Jammer Lammy (PAL-E):
-	#  - ap_check           (0x801D8008)
-	#  - ap_failed          (0x801D83E0, called from 0x801D8174)
-	#  - StopCallback       (0x800356C4, called from 0x801D8400)
-	#  - disable_ints       (0x80035B54, called from 0x800356E0)
-	#  - EnterCriticalSection
-	#
-	# For Saru! Get You (NTSC-J):
-	#  - ap_check           (0x80136950)
-	#  - ap_failed          (0x80136D28, called from 0x80136ABC)
-	#  - StopCallback       (0x8002E814, called from 0x80136D48)
-	#  - disable_ints       (0x8002ECA4, called from 0x8002E82C)
-	#  - EnterCriticalSection
-	#
-	# The return call from StopCallback to ap_failed is located at SP+0x28. We will check if
-	# at this address +0x74 exists a "li v0, 0xE6000002", which is a black rentangle passed to
-	# the DrawPrim function to clear the screen.
-	#
-	# If it exists, we will patch the thread state to return back to ap_check, as if the
-	# ap_failed function had returned.
-	#
-
-	# Compare signature, and test for v2 if does not match
-	lw t2, 0x74(t1)
-	li t3, 0x3C02E600
-	bne t2, t3, patch_ap_v15
-
-	lw t2, 0x78(t1)
-	li t3, 0x34420002
-	bne t2, t3, patch_ap_v15
-
-	# Load return address from ap_failed to ap_check
-	lw t1, 0xE8(t0)
-
-	# Adjust stack pointer
-	addi t0, 0xF0
-
-	# Save and return
-	b patch_ap_save
-
-	#
-	# Handle another variant of the v1, used by Vandal Hearts II - Tenjou no Mon (J) (SLPM-86251)
-	#  - ap_check           (0x800C4868)
-	#  - ap_failed          (0x800C4C40, called from 0x800C49D4)
-	#  - StopCallback       (0x800D2700, called from 0x800C4C58)
-	#  - disable_ints       (0x800D2B90, called from 0x800D2718)
-	#  - EnterCriticalSection
-	#
-	# Same idea, except the load is now a "li v1, 0xE6000002" at +0x64 bytes after ap_failed
-	# returns to ap_check.
-	#
-	# The offsets are the same as for v2, so we will reuse those adjusts.
-	#
-patch_ap_v15:
-	lw t2, 0x64(t1)
-	li t3, 0x3C03E600
-	bne t2, t3, patch_ap_v2
-
-	lw t2, 0x68(t1)
-	li t3, 0x34630002
-	beq t2, t3, patch_ap_adjust_v2
-
-	#
-	# We will now attempt to patch an antimodchip v2 module.
-	#
-	# This one is smarter and checks that the SCEx wobble is present in the inner tracks,
-	# to detect CD swapping; and for dumb modchips by checking for absence of the wobble
-	# in the outer tracks.
-	#
-	# The offsets for some of the checked games are:
-	#
-	# Rockman 2 - Dr. Wily no Nazo (J) (SLPS-02255):
-	#  - ap_check           (0x8006CA58)
-	#  - ap_failed          (0x8006D654, called from 0x8006CE5C and 0x8006D238)
-	#  - StopCallback       (0x80024524, called from 0x8006D66C)
-	#  - disable_ints       (0x800249B4, called from 0x8002453C)
-	#  - EnterCriticalSection
-	#
-	# The return address from StopCallback to ap_failed is located at SP+0x28, exactly as above
-	# so we will not load it again.
-	#
-	# For this other version, we will check if at this return address +0x10 bytes exists a
-	# "sh zero, 0x1F801DAA", which is used to mute the audio.
-	#
-	# If that exists, we will patch the thread state to return back to ap_check.
-	#
-patch_ap_v2:
-	# Compare signature
-	lw t2, 0x18(t1)
-	li t3, 0x3C011F80
-	bne t2, t3, patch_ap_skip
-
-	lw t2, 0x1C(t1)
-	li t3, 0xA4201DAA
-	bne t2, t3, patch_ap_skip
-
-patch_ap_adjust_v2:
-	# Load return address to from ap_failed to ap_check
-	lw t1, 0x120(t0)
-
-	# Adjust stack pointer
-	addi t0, 0x128
-
-patch_ap_save:
-	# Zero the s0 and s1 stored in the thread state, so the state machine used by ap_check exits
-	sw zero, 0x48(v0)
-	sw zero, 0x4C(v0)
-
-	# Save adjusted stack pointer and return address
-	sw t0, 0x7C(v0)
-	sw t1, 0x88(v0)
-
-.globl patch_ap_success
-patch_ap_success:
-	j 0x12341234
-
-.globl patch_ap_skip
-patch_ap_skip:
-	j 0x12341234
-
-.globl patch_ap_end
-patch_ap_end:
diff --git a/tmp/og-tonyhax.0JX/loader/patch-fpb.S b/tmp/og-tonyhax.0JX/loader/patch-fpb.S
deleted file mode 100644
index e26fb72..0000000
--- a/tmp/og-tonyhax.0JX/loader/patch-fpb.S
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# The anti-FreePSXBoot patch.
-#
-# This patch is called right at the very end of the last step in the read sector finite state
-# machine:
-# https://github.com/grumpycoders/pcsx-redux/blob/f6484e8010a40a81e4019d9bfa1a9d408637b614/src/mips/openbios/sio0/card.c#L194
-#
-# When this code is executed, the registers are as follows:
-#   - v0 contains 1, or "success".
-#   - a1 contains the read buffer
-#   - a2 contains the current sector number
-#
-# If the sector being read is sector 0 and it contains "FPBZ" at +0x7C, we modify the read data
-# so it is detected as corrupted and the game skips reading from it
-#
-# The offsets have been checked against BIOSes 2.2, 3.0, 4.1 and 4.4
-#
-.globl patch_fpb_start
-patch_fpb_start:
-	lw t0, 0x7C(a1)
-	li t1, 0x5A425046
-	bne a2, 0, patch_fpb_ret
-	bne t0, t1, patch_fpb_ret
-
-	sw zero, 0(a1)
-patch_fpb_ret:
-	j 0x5B54
-
-.globl patch_fpb_end
-patch_fpb_end:
diff --git a/tmp/og-tonyhax.0JX/loader/patch-uart.S b/tmp/og-tonyhax.0JX/loader/patch-uart.S
deleted file mode 100644
index da95257..0000000
--- a/tmp/og-tonyhax.0JX/loader/patch-uart.S
+++ /dev/null
@@ -1,121 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# This is a complete replacement for the original std_out_putc the BIOS has.
-#
-# In this function:
-#  - a0: data to bitbang
-#  - t0: working registers
-#  - t1: bits to send
-#  - t2: last IRQ flag value
-#  - t3: 0x1F800000 (I/O start address)
-#  - t4: COP0 SR value
-#
-.globl patch_uartputc_start
-patch_uartputc_start:
-	# Add start (0) and stop (1) bits to byte
-	andi a0, 0xFF
-	sll a0, 1
-	ori a0, 0x200
-
-	# Newline (after processing)
-	li t0, (0x0A << 1 | 0x200)
-
-	# Bits to send (1 start + 8 data + 1 stop)
-	li t1, 10
-
-	# Compare against newline (0x0A)
-	bne a0, t0, notnl
-
-	# If newline, prepend a 0x0D, like the original function did and increment bit count
-	sll a0, 10
-	ori a0, (0x0D << 1 | 0x200)
-	addi t1, 10
-
-notnl:
-	# We will directly manipulate the COP0 status registers instead of using EnterCriticalSection
-	# to avoid other threads/interrupts from fucking up the timing.
-	#
-	# The reason is two-fold:
-	#  - The kernel does not support reentrant calls - if something calls us while we are
-	#    executing kernel code and we generate a syscall, we'd nuke the current thread state.
-	#
-	#  - SetConf calls printf while re-configuring the TCBs (thread control blocks). Executing
-	#    *any* interrupt at that point (which includes syscalls) will cause the interrupt
-	#    handler to write the current thread state to the zero address, wiping the interrupt
-	#    trampoline at 0x80.
-	#
-	# By directly manipulating this register we're opening ourselves to all kinds of race
-	# conditions, but since this is just for debugging tonyhax, that's good enough for me.
-
-	# Load current SR state in t4
-	mfc0 t4, $12
-
-	# Clear bits 10 and 0, the same flags WarmBoot clears
-	li t0, 0xFFFFFBFE
-	and t0, t4
-	mtc0 t0, $12
-
-	# Load I/O start
-	lui t3, 0x1F80
-
-	# Set timer 0 target to 293 cycles (33868800Hz/115200bps-1)
-	li t0, 293
-	sw t0, 0x1108(t3)
-
-	# Start timer 0 in:
-	# - Source clock to SysClk (33868800Hz)
-	# - Free-running mode
-	# - Reset on reaching target value
-	# - IRQ on repeat mode (can be fired multiple times)
-	# - Toggle IRQ flag (bit 10) on every IRQ
-	#
-	# We must not use the "reached target value" flag because that seems to be affected by some
-	# kind of undocumented hardware errata. In real hardware, that flag can read zero if the
-	# elapsed cycles between timer start and read and target values are both even or odd.
-	#
-	# Also note that although we are using the IRQ bits, interrupts are actually disabled so
-	# we will busy poll the corresponding bits.
-	li t0, 0x04D8
-	sw t0, 0x1104(t3)
-
-	# Current timer IRQ flag status
-	li t2, 0x0400
-
-writebit:
-	# Emit bit via /JOY pin of port 2.
-	# We need to invert it, then put it into JOY_CTRL.13.
-	# The XOR also sets the bit JOY_CTRL.2 which enables outputing the /JOY signal
-	andi t0, a0, 1
-	sll t0, 13
-	xori t0, 0x2002
-	sh t0, 0x104A(t3)
-
-	# Shift right current buffer
-	srl a0, 1
-
-	# Decrement count while we're waiting
-	addi t1, -1
-
-	# Wait until the interrupt flag toggles
-writewait:
-	lw t0, 0x1104(t3)
-	andi t0, 0x0400
-	beq t0, t2, writewait
-
-	# Save current IRQ flag status
-	move t2, t0
-
-	# If not done, keep going
-	bne t1, zero, writebit
-
-	# Restore coprocessor flags
-	mtc0 t4, $12
-
-	jr ra
-
-.global patch_uartputc_end
-patch_uartputc_end:
diff --git a/tmp/og-tonyhax.0JX/loader/patch-vandal-hearths-2.S b/tmp/og-tonyhax.0JX/loader/patch-vandal-hearths-2.S
deleted file mode 100644
index 67f389a..0000000
--- a/tmp/og-tonyhax.0JX/loader/patch-vandal-hearths-2.S
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# This game needs a special treatment, as it has the regular antipiracy, but also an extra check
-# by calling CdGetDiskType. If it detects the disc is a burned one, it aborts.
-#
-# Furthermore, if the BIOS is an European one, it gets stuck on a loop, calling the AP module
-# forever.
-#
-# So we will just nuke the antipiracy call. This function is supposed to return a nonzero, but
-# we do not need to patch v0 as there is a load constant into v0 right before the call.
-#
-.globl patch_vandal_start
-patch_vandal_start:
-	# Load address where the call to antipiracy sits
-	la t0, 0x80040C98
-
-	# Check if it matches "jal 0x80042854"
-	lw t1, 0(t0)
-	li t2, 0x0C010A15
-	bne t1, t2, patch_vandal_return
-
-	# If it does, NOP the opcode
-	sw zero, 0(t0)
-
-.globl patch_vandal_return
-patch_vandal_return:
-	# This will be replaced with the real address
-	j 0x12341234
-
-.globl patch_vandal_end
-patch_vandal_end:
diff --git a/tmp/og-tonyhax.0JX/loader/patcher.c b/tmp/og-tonyhax.0JX/loader/patcher.c
deleted file mode 100644
index 27c1c49..0000000
--- a/tmp/og-tonyhax.0JX/loader/patcher.c
+++ /dev/null
@@ -1,147 +0,0 @@
-
-#include "bios.h"
-#include "debugscreen.h"
-#include "str.h"
-#include "patcher.h"
-
-inline void encode_j(void * jump_location, const void * jump_dest) {
-	uint32_t * words = (uint32_t *) jump_location;
-	words[0] = 0x08000000 | (((uint32_t) jump_dest >> 2) & 0x3FFFFFF);
-}
-
-inline void encode_jal(void * jump_location, const void * jump_dest) {
-	uint32_t * words = (uint32_t *) jump_location;
-	words[0] = 0x0C000000 | (((uint32_t) jump_dest >> 2) & 0x3FFFFFF);
-}
-
-inline void encode_li(void * load_location, int regnum, uint32_t value) {
-	uint32_t * words = (uint32_t *) load_location;
-
-	// LUI - Load Upper Immediate
-	words[0] = 0x3C000000 | (regnum << 16) | (value >> 16);
-
-	// ORI - OR Immediate
-	words[1] = 0x34000000 | (regnum << 21) | (regnum << 16) | (value & 0xFFFF);
-}
-
-uint8_t * install_generic_antipiracy_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_ap_start;
-	extern uint8_t patch_ap_end;
-	extern uint8_t patch_ap_skip;
-	extern uint8_t patch_ap_success;
-
-	debug_write(" * Generic antipiracy");
-
-	// Get the handler info structure
-	handler_info_t * syscall_handler = bios_get_syscall_handler();
-
-	// Get the start of the verifier function (the only one set)
-	uint32_t * verifier = (uint32_t *) syscall_handler->verifier;
-
-	/*
-	 * At opcode 20 it accesses an 4-word array which contain where to jump depending on the
-	 * syscall performed. We're interested in modifying the value for 1 (EnterCriticalSection)
-	 * so we can intercept it and defuse the antimodchip.
-	 */
-	uint32_t lw_op = verifier[20];
-	if ((lw_op >> 16) != 0x8C39) {
-		debug_write("Aborted! Please report this!");
-		return install_addr;
-	}
-
-	// Extract location of cases array
-	void ** cases_array = (void **) (lw_op & 0xFFFF);
-
-	// Copy blob
-	memcpy(install_addr, &patch_ap_start, &patch_ap_end - &patch_ap_start);
-
-	/*
-	 * Insert the jump to the original code, which we'll use if the call was not originated from
-	 * an antipiracy module.
-	 */
-	encode_j(install_addr + (&patch_ap_skip - &patch_ap_start), cases_array[1]);
-
-	/*
-	 * Insert the jump we'll use to exit the exception handler once we have finished patching up
-	 * the thread state if the call was indeed originated from an antipiracy module.
-	 *
-	 * We'll use the address of syscall(0) which behaves as a nop to exit the exception.
-	 */
-	encode_j(install_addr + (&patch_ap_success - &patch_ap_start), cases_array[0]);
-
-	// Finally replace
-	cases_array[1] = install_addr;
-
-	return install_addr + (&patch_ap_end - &patch_ap_start);
-}
-
-uint8_t * install_vandal_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_vandal_start;
-	extern uint8_t patch_vandal_return;
-	extern uint8_t patch_vandal_end;
-
-	debug_write(" * Vandal Hearths 2 AP");
-
-	// Copy blob
-	memcpy(install_addr, &patch_vandal_start, &patch_vandal_end - &patch_vandal_start);
-
-	// Hook into call 16 of table B (OutdatedPadGetButtons), which is called once per frame
-	void ** b0_tbl = GetB0Table();
-
-	// Insert call to real function
-	encode_j(install_addr + (&patch_vandal_return - &patch_vandal_start), b0_tbl[0x16]);
-
-	// Replace it now
-	b0_tbl[0x16] = install_addr;
-
-	// Advance installation address
-	return install_addr + (&patch_vandal_end - &patch_vandal_start);
-}
-
-uint8_t * install_fpb_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_fpb_start;
-	extern uint8_t patch_fpb_end;
-
-	debug_write(" * FreePSXBoot");
-
-	// Copy blob
-	memcpy(install_addr, &patch_fpb_start, &patch_fpb_end - &patch_fpb_start);
-
-	// Install it
-	encode_jal((void *) 0x5B40, install_addr);
-
-	// Advance installation address
-	return install_addr + (&patch_fpb_end - &patch_fpb_start);
-}
-
-void patcher_apply(const char * boot_file) {
-	// We have plenty of space at the end of table B
-	uint8_t * install_addr = (uint8_t *) (GetB0Table() + 0x5E);
-
-	// Install patches
-	debug_write("Installing patches:");
-
-	// Install a suitable antimodchip patch
-	if (strcmp(boot_file, "cdrom:\\SLUS_009.40;1") == 0) {
-		install_addr = install_vandal_patch(install_addr);
-	} else {
-		install_addr = install_generic_antipiracy_patch(install_addr);
-	}
-
-	// FreePSXBoot does not work on PS2 so skip its installation
-	if (bios_is_ps1()) {
-		install_addr = install_fpb_patch(install_addr);
-	}
-}
-
-void patcher_apply_softuart() {
-	// Exports defined by the patch
-	extern uint8_t patch_uartputc_start;
-	extern uint8_t patch_uartputc_end;
-
-	// Overwrite BIOS' std_out_putchar function
-	memcpy(BIOS_A0_TABLE[0x3C], &patch_uartputc_start, &patch_uartputc_end - &patch_uartputc_start);
-}
diff --git a/tmp/og-tonyhax.0JX/loader/patcher.h b/tmp/og-tonyhax.0JX/loader/patcher.h
deleted file mode 100644
index 5b24f53..0000000
--- a/tmp/og-tonyhax.0JX/loader/patcher.h
+++ /dev/null
@@ -1,12 +0,0 @@
-
-#pragma once
-
-/**
- * Install and apply suitable BIOS patches.
- */
-void patcher_apply(const char * boot_file);
-
-/**
- * Installs the softUART patch.
- */
-void patcher_apply_softuart();
diff --git a/loader/secondary-ff9.ld b/loader/secondary-ff9.ld
new file mode 100644
index 0000000..bd6af40
--- /dev/null
+++ b/loader/secondary-ff9.ld
@@ -0,0 +1,36 @@
+MEMORY {
+	ram(wrx)	:ORIGIN = 0x801F4380, LENGTH = 0x7E00
+}
+SECTIONS {
+	. = 0x801F4380;
+	PROVIDE(__RO_START__ = .);
+	.text :
+	{
+		*(.start)
+		*(.text .text.*)
+	} >ram
+	.rodata :
+	{
+		*(.rodata .rodata.*)
+	} >ram
+	.data :
+	{
+		*(.data .data.*)
+	} >ram
+	PROVIDE(__CRC_START__ = .);
+	.crc :
+	{
+		*(.crc .crc.*)
+	} >ram
+	PROVIDE(__BSS_START__ = .);
+	.bss :
+	{
+		*(.bss .bss.*)
+	} >ram
+	PROVIDE(__BSS_END__ = .);
+	/DISCARD/ :
+	{
+		*(*)
+	}
+}
+ENTRY (start)
diff --git a/tmp/og-tonyhax.0JX/loader/secondary.c b/loader/secondary.c
index b320366..0fc25ec 100644
--- a/tmp/og-tonyhax.0JX/loader/secondary.c
+++ b/loader/secondary.c
@@ -10,13 +10,272 @@
 #include "crc.h"
 #include "debugscreen.h"
 #include "gpu.h"
-#include "patcher.h"
+#include "ap-bypass.h"
 #include "integrity.h"
 #include "io.h"
 
+//to test ROM functionality in emulation via boot CD, uncomment the following 2 lines:
+//#undef ROM
+//#define ROM
+
+//to test XSTATION ROM functionality in emulation via boot CD, uncomment the following 4 lines:
+//#undef XSTATION
+//#define XSTATION
+//#undef ROM
+//#define ROM
+
+//to test behavior without any APv2 bypasses enabled (useful for testing D0 AP bypass codes via save game file gameshark functionality rather then internal activate_anti_piracy() function), uncomment:
+//#define AP_BYPASS_DISABLE
+
+uint8_t sscmd;
+uint8_t cdcontrollerver[4];
+
+const char * p5_localized;
+const char * region_name;
+
+bool calibrate_laser = 0; // Only Japanese VC2 and VC3 consoles need this so it is off by default
+bool bugged_setsession = 0; // VC0 A, VC0 B, and VC1 A CDROM Controller BIOS versions all have a buggy SetSession command that requires a special work around to use
+bool enable_unlock = 1; // Disabled on VC0A and VC0B Japanese CDROM Controller BIOS versions automatically. On VC1A+ the testregion command is run and if the region is Japan it is also disabled.
+bool controller_input = 0; // When enabled, debug_write does not display the repeat messages counter. This is so we can draw a blank line and then wait for controller input using vsync in debug_write.
+bool installed_cheat_engine = 0; // The cheat engine is installed when parse_memcard_save_gameshark_codes() completes. Some games may go on to set explicit anti-piracy bypass GameShark codes however, so to prevent the cheat engine from being installed twice (which is wasteful) we set a flag here.
+bool did_read_mc = 0; // We need to set the GameShark codes AFTER the last bios_reintialize(). I want to call bios_reinitilize() after reading the memory card data to prevent anything screwy in booting games, so we can just parse the data later after the final bios_reinitialize since it's still in RAM.
+uint8_t number_of_gameshark_code_lines; // part of my basic format to store codes, this tells us how many we will activate
+uint8_t * user_start = (uint8_t *) 0x80010000;
+uint16_t mc_base = 0x102; // start of gs code data in memory card buffer
+bool no_system_cnf = 0;
 // Loading address of tonyhax, provided by the secondary.ld linker script
 extern uint8_t __RO_START__, __BSS_START__, __BSS_END__;
 
+// for controller input functions
+void * address;		// For Calculating BIOS Functions
+uint8_t j;			// Joypad
+uint8_t padbuf[2][0x22];	// Joypad Buffers
+
+#if !defined TOCPERFECT
+#if defined ROM
+void run_shell() {
+	// runs Sony BIOS. Can access CD Player/Memory Card Manager. Can not boot any discs, even ones that normally work without the flash cart inserted in the console. This has been adapted code from the SCPH-1001 decomp: https://github.com/ogamespec/psxdev/blob/97fbb2d03e5aff4449097afd2b59690002cb2341/reverse/Main.c#L395
+
+	debug_write("Starting Sony BIOS...");
+	memcpy((void*)0x80030000, (void*)0xBFC18000, 0x67FF0); // uses 0x80030000-0x80077FF0
+	FlushCache();
+	((void (*)(void))0x80030000)();
+}
+#endif
+
+void controller_input_start() {
+	controller_input = 1; // disable the repeat counter used in debug_write until controller input is done, see debugscreen.c
+	// BIOS Function InitPAD(buf1,sz1,buf2,sz2)
+	address = (uint32_t *) GetB0Table()[0x12];
+	((void (*)(uint8_t*,uint32_t,uint8_t*,uint32_t)) address)(padbuf[0],0x22,padbuf[1],0x22); // BIOS InitPAD(buf1,sz1,buf2,sz2) exec
+	// BIOS Function StartPAD()
+	address = (void *) (GetB0Table()[0x13]);
+	((void (*)(void)) address)();	// BIOS StartPad exec
+}
+
+void controller_input_stop() { // this doubles as 'closing' the memory card functions
+	controller_input = 0; // Set debug_write back to normal (enable repeat counter) as controller input is done
+	// BIOS Function StopPAD()
+	address = (void *) (GetB0Table()[0x14]);
+	// StopPAD() as we are done using Joypad input
+	((void (*)(void)) address)();	// BIOS StopPad exec
+}
+
+void mc_controller_wait_on_error() {
+	for(volatile int i = 0; i < 0x100000; i++); // Pause to not spam a memory card read error message if O is pressed down
+}
+
+void read_memcard() {
+/*
+PSX Official Docs
+
+InitCARD
+Initialize Memory Card BIOS.
+Library Header File Introduced Documentation Date
+libcard.lib libapi.h 3.0 12/14/98
+Syntax
+void InitCARD(
+long val) Specify sharing with controller
+Explanation
+Initializes the Memory Card BIOS and enters an idle state. val specifies whether or not there is sharing with
+the controller. (0: not shared; 1: shared.)
+When the BIOS is subsequently put into operation by StartCARD(), the low-level interface functions that
+begin with “ _card” can be used directly.
+The Memory Card file system uses these interfaces internally, so InitCARD() needs to be executed before
+_bu_init().
+There is no effect on the controller.
+*/
+
+/*
+No $ PSX SPX File Error info
+
+File Error Numbers for B(54h) and B(55h)
+  00h okay (though many successful functions leave old error code unchanged)
+  02h file not found
+  06h bad device port number (tty2 and up)
+  09h invalid or unused file handle
+  10h general error (physical I/O error, unformatted, disk changed for old fcb)
+  11h file already exists error (create/undelete/rename)
+  12h tried to rename a file from one device to another device
+  13h unknown device name
+  16h sector alignment error, or fpos>=filesize, unknown seektype or ioctl cmd
+  18h not enough free file handles
+  1Ch not enough free memory card blocks
+  FFFFFFFFh invalid or unused file handle passed to B(55h) function
+*/
+	debug_write("Reading MC...");
+	int32_t read;
+	// BIOS Function InitCard(pad_enable)
+	int32_t pad_enable = 1; 
+	address = (uint32_t *) GetB0Table()[0x4A];
+	((void (*)(int32_t*)) address)(&pad_enable);
+	// BIOS Function StartCard()
+	address = (void *) (GetB0Table()[0x4B]);
+	((void (*)(void)) address)();
+	// BIOS Function _bu_init()
+	address = (void *) (GetB0Table()[0x55]);
+	((void (*)(void)) address)();
+	int32_t mc_fd = FileOpen("bu00:TONYHAXINTGS", FILE_READ);
+
+	// The kernel will fail to read if we don't wait a bit (here, ~1/10th of a second) (NOTE: this is not exactly 1/10th of a second, what I'm doing here, it is a bit more). This is a known issue as specified in LIBOVR46.PDF section 5-11: "If read() or write() is issued immediately after open(), an error occurs". I noticed that entry.S does this so I do it here as well now
+	mc_controller_wait_on_error();
+
+	if(mc_fd == -1) {
+		mc_controller_wait_on_error();
+		debug_write("Can not read MC, read error %d", GetLastError());
+		#if defined FREEPSXBOOT
+			debug_write("Ensure the FreePSXBoot memory card has been removed");
+		#endif
+		debug_write("Please try reinserting MC");
+	}
+
+	if (mc_fd > 0) {
+		read = FileRead(mc_fd, user_start, 0x2000); // read the entire file "TONYHAXINTGS" to the start of 'user RAM' (which will be cleared later before booting an executable). So 0x80010000-0x80012000 in RAM contains the contents of "TONYHAXINTGS". 
+		// 8192 % 64 = 128
+		FileClose(mc_fd);
+		
+		if (read == -1) {
+			mc_controller_wait_on_error();
+			debug_write("TONYHAXINTGS read error %d", GetLastError());
+		} else {
+			number_of_gameshark_code_lines = user_start[mc_base + 1];
+			debug_write("%d code lines detected", number_of_gameshark_code_lines);
+
+			uint8_t sum;
+			uint8_t prev = 0;
+			uint8_t next;
+			uint8_t checksum_in_save_file = user_start[mc_base];
+
+			for (int i = 0x103; i < 0x2000; i++)
+			{
+				//debug_write("%x: @ %x", &user_start[i], user_start[i]);
+				next = user_start[i];
+				sum = prev + next;
+				sum &= 0xFF;
+				prev = sum;
+			}
+
+			if(checksum_in_save_file == sum) {
+				debug_write("Checksum: %x Verified", sum);
+				did_read_mc = 1; // set flag to parse codes uploaded to RAM, right before clearing RAM itself and booting the game
+			} else {
+				debug_write("Checksum: %x did not match the expected checksum %x!", sum, checksum_in_save_file);
+				debug_write("No codes enabled, the TONYHAXINTGS file may corrupted");
+			}
+		}
+	}
+}
+
+void parse_memcard_save_gameshark_codes() {
+	/*
+	TONYHAXINTGS format:
+
+	0x00-0x101 = static save file data
+
+	0x102 = checksum generated by thigsgen
+
+	0x103 = number of code lines in hex
+
+	0x104-0x107 = gameshark code address (may or may not include code prefix i.e. D0, E0, 30, or 80 could be 0x104)
+
+	0x108-0x109 = gameshark code mod value
+		
+	0x110-0x103 = 2nd gameshark code address
+
+	0x114-0x115 = 2nd gameshark code mod value (and then so on and so on for number of code lines in hex number)
+	*/
+
+	uint32_t gameshark_code_address;
+	uint8_t gs_code_type;
+
+	/*
+	uint32_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	for (int i = 0; i < 0x2000; i++)
+	{
+		debug_write("%x: @ %x", &user_start[i], user_start[i]);
+		next = user_start[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Memory card buffer checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	*/
+
+	for(int i = 0; i < number_of_gameshark_code_lines; i++) {
+		
+		gs_code_type = user_start[mc_base + 5];
+			
+		if(
+			(gs_code_type == 0xD0) || 
+			(gs_code_type == 0xD1) || 
+			(gs_code_type == 0xD2) || 
+			(gs_code_type == 0xD3) || 
+			(gs_code_type == 0xE0) || 
+			(gs_code_type == 0xE1) ||
+			(gs_code_type == 0xE2) || 
+			(gs_code_type == 0xE3) || 
+			(gs_code_type == 0x30)
+		) {
+			user_start[mc_base + 5] = 0x80; // we need to convert the prefix to the real address first byte of 0x80 for the cheat engine
+		}
+
+		gameshark_code_address = user_start[mc_base + 2] + (user_start[mc_base + 3] << 8) + (user_start[mc_base + 4] << 16) + (user_start[mc_base + 5] << 24);
+		//debug_write("GS Code Addr: %x", gameshark_code_address);
+
+		if(
+			(gs_code_type == 0x80) || 
+			(gs_code_type == 0xD0) || 
+			(gs_code_type == 0xD1) || 
+			(gs_code_type == 0xD2) || 
+			(gs_code_type == 0xD3)
+
+		) {
+			uint16_t gameshark_code_mod_val = user_start[mc_base + 6] + (user_start[mc_base + 7] << 8);
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_16bit_code(gameshark_code_address, gameshark_code_mod_val, gs_code_type);
+		}
+
+		if(
+			(gs_code_type == 0x30) || 
+			(gs_code_type == 0xE0) || 
+			(gs_code_type == 0xE1) || 
+			(gs_code_type == 0xE2) || 
+			(gs_code_type == 0xE3) 
+
+		) {
+			uint8_t gameshark_code_mod_val = user_start[mc_base + 6];
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_8bit_code(gameshark_code_address, gameshark_code_mod_val, gs_code_type);
+		}
+			
+		mc_base = (mc_base + 6); // advance 6 bytes from current val
+	}
+}
+#endif // TOCPERFECT
+
 void log_bios_version() {
 	/*
 	 * "System ROM Version 4.5 05/25/00 A"
@@ -31,7 +290,7 @@ void log_bios_version() {
 	}
 
 	debug_write("Console: %s", bios_is_ps1() ? "PS1": "PS2");
-	debug_write("BIOS: v%s", version);
+	debug_write("System BIOS: %s", version);
 }
 
 bool backdoor_cmd(uint_fast8_t cmd, const char * string) {
@@ -65,43 +324,6 @@ bool backdoor_cmd(uint_fast8_t cmd, const char * string) {
 }
 
 bool unlock_drive() {
-	uint8_t cd_reply[16];
-
-	// Run "GetRegion" test
-	uint8_t test = CD_TEST_REGION;
-	cd_command(CD_CMD_TEST, &test, 1);
-
-	// Should succeed with 3
-	if (cd_wait_int() != 3) {
-		debug_write("Region read failed");
-		return false;
-	}
-
-	// Read actual region text and null terminate it
-	int len = cd_read_reply(cd_reply);
-	cd_reply[len] = 0;
-
-	// Compare which is the fifth string we have to send to the backdoor
-	const char * region_name;
-	const char * p5_localized;
-	if (strcmp((char *) cd_reply, "for Europe") == 0) {
-		region_name = "European";
-		p5_localized = "(Europe)";
-	} else if (strcmp((char *) cd_reply, "for U/C") == 0) {
-		region_name = "American";
-		p5_localized = "of America";
-	} else if (strcmp((char *) cd_reply, "for NETEU") == 0) {
-		region_name = "NetYaroze (EU)";
-		p5_localized = "World wide";
-	} else if (strcmp((char *) cd_reply, "for NETNA") == 0) {
-		region_name = "NetYaroze (US)";
-		p5_localized = "World wide";
-	} else {
-		// +4 to skip past "for "
-		debug_write("Unsupported region: %s", (char *) (cd_reply + 4));
-		return false;
-	}
-
 	debug_write("Drive region: %s", region_name);
 
 	// Note the kernel's implementation of strlen returns 0 for nulls.
@@ -121,11 +343,31 @@ bool unlock_drive() {
 	return true;
 }
 
+#if !defined TOCPERFECT
 void wait_lid_status(bool open) {
 	uint8_t cd_reply[16];
+	
+	controller_input_start();
 
 	uint8_t expected = open ? 0x10 : 0x00;
 	do {
+
+		j = padbuf[0][3] ^ 0xFF;
+		debug_write(" "); // Vblank wait for controller input
+
+#if defined ROM // this is more optimized for variable button presses then otherwise if we didn't test both statements in an else if
+		if(j == 0x40) { // X button
+			controller_input_stop();
+			run_shell(); // launch Sony BIOS
+		} else if(j == 0x20) { // Circle button
+			read_memcard();
+		}
+#else // booting the shell is unnecessary for every other boot method besides the ROM so we don't include it
+		if(j == 0x20) { // Circle button
+			read_memcard();
+		}
+#endif // ROM
+
 		// Issue Getstat command
 		// We cannot issue the BIOS CD commands yet because we haven't called CdInit
 		cd_command(CD_CMD_GETSTAT, NULL, 0);
@@ -137,20 +379,158 @@ void wait_lid_status(bool open) {
 		cd_read_reply(cd_reply);
 
 	} while ((cd_reply[0] & 0x10) != expected);
+
+	controller_input_stop();
 }
 
-void try_boot_cd() {
-	int32_t read;
+bool is_lid_open() {
+	uint8_t cd_reply[16];
 
-	debug_write("Swap CD now");
-	wait_lid_status(true);
-	wait_lid_status(false);
+	// Issue Getstat command
+	// We cannot issue the BIOS CD commands yet because we haven't called CdInit
+	cd_command(CD_CMD_GETSTAT, NULL, 0);
+
+	// Always returns 3, no need to check
+	cd_wait_int();
+
+	// Always returns one, no need to check either
+	cd_read_reply(cd_reply);
+
+	if(cd_reply[0]==0x10) {
+		return true;
+	} else {
+		return false;
+	}   
+}
+
+bool licensed_drive() {
+	uint8_t getid_response[9];
+	unsigned char gid;
 
+	while(1) {
+    	cd_command(CD_CMD_GETID,0,0);
+		gid = cd_wait_int();
+		if(gid!=5)
+			break;
+	}
+	
+    cd_wait_int();
+	cd_read_reply(getid_response);
+
+	if(getid_response[0]==0x02 && getid_response[1]==0x00 && getid_response[2]==0x20 && getid_response[3]==0x00) {
+		return true;
+	} else {
+		return false;
+	}   
+}
+#endif // TOCPERFECT
+
+void re_cd_init() {
+	debug_write("Reinitializing kernel"); 
+	bios_reinitialize();
+	bios_inject_disc_error();
+	debug_write("Stopping Motor"); // Significantly improves reading data from disc
+	cd_command(CD_CMD_STOP, NULL, 0); cd_wait_int(); cd_wait_int();
+	
 	debug_write("Initializing CD");
 	if (!CdInit()) {
 		debug_write("Init failed");
 		return;
 	}
+}
+
+void try_boot_cd() {
+	int32_t read;
+#if defined FREEPSXBOOT
+	debug_write("REMOVE THE FREEPSXBOOT MEMORY CARD FROM YOUR CONSOLE NOW");
+#elif defined ROM
+	debug_write("With the CD drive open, press X to boot the Sony BIOS or");
+	debug_write("Press O to enable GS codes");
+#endif
+
+#if !defined XSTATION
+	uint8_t cbuf[4]; // CD Command Buffer
+
+#if !defined TOCPERFECT
+	if(enable_unlock) {
+		#if !defined ROM
+		debug_write("With the CD drive open, press O to enable GS codes");
+		#endif
+		debug_write("Put in a backup or import disc, then close the drive lid");
+		wait_lid_status(true); // doesn't wait during the ROM method, unsure why but it is what we want as it allows us to auto-boot with the ROM boot method
+		wait_lid_status(false);
+	} else {
+		if(is_lid_open() || !licensed_drive()) {	// If lid is open drive is not licensed, and if lid is closed we check if it is licensed (if it is not licensed but not open then the drive is closed and the user can open it and license it)
+			debug_write("Put in a real NTSC-J PSX game disc, then block the lid sensor");
+			wait_lid_status(true);
+			wait_lid_status(false); // Blocking lid sensor = 'closing lid'
+
+            debug_write("Initializing CD");	// Drive will be in licensed state after this is successful
+			if (!CdInit()) {
+				debug_write("Init failed");
+				debug_write("Try unblocking then blocking the lid sensor again");
+				return;
+			}
+		} // Drive is licensed and the lid is 'closed' at this point
+		debug_write("Drive is licensed");
+           
+		debug_write("Stopping motor");
+		cd_command(CD_CMD_STOP,0,0); cd_wait_int(); cd_wait_int();
+
+		debug_write("Press O to enable GS codes");
+		controller_input_start();
+
+		debug_write("Keep the lid sensor blocked until turning off the console");
+		debug_write("Remove the real NTSC-J PSX game disc");
+		debug_write("Put in a backup/import disc, then press X"); // Thanks MottZilla!
+            
+		while(1) { 
+			j = padbuf[0][3] ^ 0xFF;
+
+			if(j == 0x40) {
+				break; // X button boots disc
+			} else if(j == 0x20) { // Circle button enables codes
+				read_memcard(); // this allows Japanese console users to enable user supplied GameShark codes without having to unblock the lid sensor, resetting authentication which would just be more unnecessary steps.
+			}
+
+			debug_write(" "); // Vblank wait for controller input
+		}
+	    controller_input_stop();
+	}
+#endif // TOCPERFECT
+
+	if(!enable_unlock) {
+		if(bugged_setsession) {
+			debug_write("Sending SetSessionSuperUltraCommandSmash v2, please wait"); // DuckStation can get stuck here if you swap the disc and don't wait a few seconds (DuckStation auto starts the motor on disc swap which is actually super annoying since if this executes while it is doing the emulated motor on it will lock up, and it doesn't even need to work like that since real hardware doesn't and game code always starts up a swap disc for i.e. multi-disc games). DuckStation also always emulates a VC1A which triggers this code path with any Japanese BIOS.
+			sscmd = 2; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int(); // There is a 3rd response we are ignoring by sending SetSession 1 next ASAP after SetSession 2.
+			sscmd = 1; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int();
+		} else {
+			debug_write("Sending SetSession 1");
+			sscmd = 1; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int();
+		
+			if(calibrate_laser) { // VC2 and VC3s do auto Bias/Gain calibration when reading a newly inserted real NTSC-J PS1 disc. A swapped in CD-R or just a different disc in general needs this to be updated
+        		debug_write("Calibrating laser");
+        		cbuf[0] = 0x50; cbuf[1] = 0x38; cbuf[2] = 0x15; cbuf[3] = 0x0A;	// ModeCompensateTrackingAutoGain
+				cd_command(CD_CMD_TEST,&cbuf[0],4); 
+				cd_wait_int();
+			}		
+		}
+	}
+#else // XSTATION DEFINED
+	debug_write("Open and then close the CD drive lid");
+	wait_lid_status(true); // doesn't wait during the ROM method, unsure why but it is what we want as it allows us to auto-boot with the ROM boot method
+	wait_lid_status(false);
+#endif // XSTATION
+
+	/*
+	We have to re-initilize the BIOS, stop, and init in that order to prevent the process from possibly freezing at this point on Japanese consoles. 
+	
+	The first reason this is required is because the SetSessionSuperUltraCommandSmash screws up interrupts since we are sending the 2nd SetSession command before the possible 3rd interrupt (which is a second INT5 response sent if session 2 does not actually exist). 
+		
+	The second reason is because of how we are using the BIOS controller functions, to go back to a clean state a bios re-intialization also accomplishes that.
+	*/
+
+	re_cd_init();
 
 	/*
 	 * Use the space the BIOS has allocated for reading CD sectors.
@@ -163,10 +543,17 @@ void try_boot_cd() {
 	uint8_t * data_buffer = (uint8_t *) (bios_is_ps1() ? 0xA000B070 : 0xA000A8D0);
 
 	debug_write("Checking game region");
-	if (CdReadSector(1, 4, data_buffer) != 1) {
+#if defined TOCPERFECT	
+    if (CdReadSector(1, 15, data_buffer) != 1) { // Real license data sector is copied to sector 15 by TOCPerfect Patch before it writes Japanese license data to sector 4 to allow booting via CD Player Swap Trick on early SCPH-3000 models
 		debug_write("Failed to read sector");
 		return;
 	}
+#else
+    if (CdReadSector(1, 4, data_buffer) != 1) {
+		debug_write("Failed to read sector");
+		return;
+	}
+#endif
 
 	const char * game_region;
 	bool game_is_pal = false;
@@ -200,7 +587,7 @@ void try_boot_cd() {
 	uint32_t tcb = BIOS_DEFAULT_TCB;
 	uint32_t event = BIOS_DEFAULT_EVCB;
 	uint32_t stacktop = BIOS_DEFAULT_STACKTOP;
-	const char * bootfile = "cdrom:PSX.EXE;1";
+	char * bootfile = "cdrom:PSX.EXE;1";
 
 	char bootfilebuf[32];
 	debug_write("Loading SYSTEM.CNF");
@@ -221,18 +608,34 @@ void try_boot_cd() {
 		config_get_hex((char *) data_buffer, "TCB", &tcb);
 		config_get_hex((char *) data_buffer, "EVENT", &event);
 		config_get_hex((char *) data_buffer, "STACK", &stacktop);
+
+#if defined TOCPERFECT
+		if (config_get_string((char *) data_buffer, "BOOY", bootfilebuf)) {
+			bootfile = bootfilebuf;
+		} else {
+			uint32_t errorCode = GetLastError();
+			if (errorCode != FILEERR_NOT_FOUND) {
+				debug_write("Open error %d", errorCode);
+				return;
+			}
+
+			debug_write("Not found");
+		}
+#else
 		if (config_get_string((char *) data_buffer, "BOOT", bootfilebuf)) {
 			bootfile = bootfilebuf;
+		} else {
+			uint32_t errorCode = GetLastError();
+			if (errorCode != FILEERR_NOT_FOUND) {
+				debug_write("Open error %d", errorCode);
+				return;
+			}
+
+			debug_write("Not found");
 		}
-
+#endif
 	} else {
-		uint32_t errorCode = GetLastError();
-		if (errorCode != FILEERR_NOT_FOUND) {
-			debug_write("Open error %d", errorCode);
-			return;
-		}
-
-		debug_write("Not found");
+		no_system_cnf = true;
 	}
 
 	// Use string format to reduce ROM usage
@@ -241,6 +644,8 @@ void try_boot_cd() {
 	debug_write(" * %s = %x", "STACK", stacktop);
 	debug_write(" * %s = %s", "BOOT", bootfile);
 
+	re_cd_init(); // Reset one last time to avoid potential lockups (here be dragons)
+
 	/*
 	 * SetConf is run by BIOS with interrupts disabled.
 	 *
@@ -254,8 +659,12 @@ void try_boot_cd() {
 	EnterCriticalSection();
 	SetConf(event, tcb, stacktop);
 
+#if !defined TOCPERFECT
+	if(did_read_mc) // before clearing RAM (which contains our mem card buffer if applicable) but after last bios_reinitalize/setconf()
+		parse_memcard_save_gameshark_codes();
+#endif
+
 	debug_write("Clearing RAM");
-	uint8_t * user_start = (uint8_t *) 0x80010000;
 	bzero(user_start, &__RO_START__ - user_start);
 
 	debug_write("Reading executable header");
@@ -272,6 +681,53 @@ void try_boot_cd() {
 		return;
 	}
 
+	/* 
+	King's Field Japan (SLPS_00017) is a very early PSX.EXE Japan game. While the PSX.EXE is having 0x34/0x38 contain SP values, these are apparently garbage and not being used in reality by a real BIOS boot. These ARE being used by both our exec calls below however so we need to zero out that garbage so it is not used, which finally allows King's Feild (and most likely other PSX.EXE games) to boot correctly.
+
+	From No $ PSX SPX:
+
+  	030h      Initial SP/R29 & FP/R30 Base (usually 801FFFF0h) (or 0=None)
+  	034h      Initial SP/R29 & FP/R30 Offs (usually 0, added to above Base)
+	
+	Note: In bootfiles, SP is usually 801FFFF0h (ie. not 801FFF00h as in system.cnf). When SP is 0, the unmodified caller's stack is used. In most cases (except when manually calling DoExecute), the stack values in the exeheader seem to be ignored though (eg. replaced by the SYSTEM.CNF value)
+	*/
+	if(no_system_cnf) {
+		for(int i = 0; i < 8; i++) {
+    		data_buffer[0x30 + i] = 0;
+		}
+	}
+
+	/*
+	uint32_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	uint8_t * ce = (uint8_t *) 0xC000;
+
+	for (int i = 0; i < 0x100; i++)
+	{
+		//debug_write("%x: @ %x", &ce[i], ce[i]);
+		next = ce[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Cheat engine checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	
+	uint8_t * codes = (uint8_t *) 0xD000;
+
+	for (int i = 0; i < 0x1FFB; i++)
+	{
+		//debug_write("%x: @ %x", &codes[i], codes[i]);
+		next = codes[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Cheat engine enabled codes Checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	*/
+
 	exe_header_t * exe_header = (exe_header_t *) (data_buffer + 0x10);
 
 	// If the file overlaps tonyhax, we will use the unstable LoadAndExecute function
@@ -287,6 +743,15 @@ void try_boot_cd() {
 		// Restore original error handler
 		bios_restore_disc_error();
 
+#if !defined XSTATION
+#if !defined AP_BYPASS_DISABLE
+		activate_anti_anti_piracy(bootfile, (int32_t) exe_header->load_addr);
+#endif
+#endif
+
+		if((did_read_mc) && (!cheat_engine_installed))
+			install_cheat_engine();
+
 		LoadAndExecute(bootfile, exe_header->initial_sp_base, exe_header->initial_sp_offset);
 		return;
 	}
@@ -300,8 +765,6 @@ void try_boot_cd() {
 
 	FileClose(exe_fd);
 
-	patcher_apply(bootfile);
-
 	if (game_is_pal != gpu_is_pal()) {
 		debug_write("Switching video mode");
 		debug_switch_standard(game_is_pal);
@@ -312,6 +775,15 @@ void try_boot_cd() {
 	// Restore original error handler
 	bios_restore_disc_error();
 
+#if !defined XSTATION
+#if !defined AP_BYPASS_DISABLE
+	activate_anti_anti_piracy(bootfile, (int32_t) exe_header->load_addr);
+#endif
+#endif
+
+	if((did_read_mc) && (!cheat_engine_installed))
+		install_cheat_engine();
+
 	// Games from WarmBoot start with interrupts disabled
 	EnterCriticalSection();
 
@@ -322,6 +794,7 @@ void try_boot_cd() {
 }
 
 void main() {
+	
 	// Undo all possible fuckeries during exploiting
 	bios_reinitialize();
 
@@ -338,24 +811,75 @@ void main() {
 
 	bios_inject_disc_error();
 	log_bios_version();
+    
+	debug_write("Resetting Drive");
+	cd_drive_init();
+
+	sscmd = 0x20; cd_command(CD_CMD_TEST,(unsigned char *)&sscmd,1); cd_wait_int(); 
+	cd_read_reply(cdcontrollerver);	// Test Command $19,$20 gets the CDROM BIOS
+	debug_write("CD BIOS: %x", *(uint32_t*) cdcontrollerver);
+   	if(cdcontrollerver[0] == 0x94) {    
+        bugged_setsession = 1;
+        enable_unlock = 0; // VC0 A and VC0 B are both from 1994 and don't support the getregion command to figure out if it is unlockable or not.
+    } 
+    else if(cdcontrollerver[1] == 0x05 && cdcontrollerver[2] == 0x16 && cdcontrollerver[0] == 0x95 && cdcontrollerver[3] == 0xC1) {     
+        bugged_setsession = 1; // NOTE I don't think this will ever be triggered but just in case. Earliest SCPH-3000s and late SCPH-1000s are VC0B and later SCPH-3000s are VC1B. Only unlockable systems have VC1A it seems.
+    }
+    else if((cdcontrollerver[3] == 0xC2) || (cdcontrollerver[3] == 0xC3)) {   
+        calibrate_laser = 1;
+    }
+
+#if !defined XSTATION
+	if(enable_unlock) {
+		uint8_t cd_reply[16];
+		// Run "GetRegion" test
+		uint8_t test = CD_TEST_REGION;
+		cd_command(CD_CMD_TEST, &test, 1);
+
+		// Should succeed with 3
+		if (cd_wait_int() != 3) {
+			debug_write("Region read failed");
+			return;
+		}
 
-	debug_write("Resetting drive");
-	if (!cd_drive_init()) {
-		debug_write("Reset failed");
-		return;
-	}
+		// Read actual region text and null terminate it
+		int len = cd_read_reply(cd_reply);
+		cd_reply[len] = 0;
+
+		// Compare which is the fifth string we have to send to the backdoor
+		if (strcmp((char *) cd_reply, "for Europe") == 0) {
+			region_name = "European";
+			p5_localized = "(Europe)";
+		} else if (strcmp((char *) cd_reply, "for U/C") == 0) {
+			region_name = "American";
+			p5_localized = "of America";
+		} else if (strcmp((char *) cd_reply, "for NETEU") == 0) {
+			region_name = "NetYaroze (EU)";
+			p5_localized = "World wide";
+		} else if (strcmp((char *) cd_reply, "for NETNA") == 0) {
+			region_name = "NetYaroze (US)";
+			p5_localized = "World wide";
+		} else if (strcmp((char *) cd_reply, "for Japan") == 0) {
+			enable_unlock = 0;
+		} else {
+			// +4 to skip past "for "
+			debug_write("Unsupported region: %s", (char *) (cd_reply + 4));
+			return;
+		}
 
-	debug_write("Unlocking drive");
-	if (!unlock_drive()) {
-		return;
+		if(enable_unlock) { // Check again, this could be false now
+			#if defined TOCPERFECT // Get TOC via reset + unlock instead of unlock + opening/closing the drive lid for auto loading in TOCPerfect, thanks MottZilla!
+				debug_write("Resetting drive");
+				cd_drive_reset();
+			#endif
+			debug_write("Unlocking drive");
+			if (!unlock_drive())
+				return;
+		}
 	}
+#endif // XSTATION
 
 	while (1) {
-#if SOFTUART_PATCH
-		patcher_apply_softuart();
-		std_out_puts("SoftUART ready\n");
-#endif
-
 		try_boot_cd();
 
 		debug_write("Reinitializing kernel");
diff --git a/tmp/og-tonyhax.0JX/loader/secondary.ld b/loader/secondary.ld
index 7dc880a..dfd4eaa 100644
--- a/tmp/og-tonyhax.0JX/loader/secondary.ld
+++ b/loader/secondary.ld
@@ -1,8 +1,8 @@
 MEMORY {
-	ram(wrx)	:ORIGIN = 0x801FA100, LENGTH = 0x3F00
+	ram(wrx)	:ORIGIN = 0x801F6200, LENGTH = 0x7E00
 }
 SECTIONS {
-	. = 0x801FA100;
+	. = 0x801F6200;
 	PROVIDE(__RO_START__ = .);
 	.text :
 	{
diff --git a/loader/tonyhax-tpl-ff9.mcs b/loader/tonyhax-tpl-ff9.mcs
new file mode 100644
index 0000000..4001e74
Binary files /dev/null and b/loader/tonyhax-tpl-ff9.mcs differ
diff --git a/loader/tonyhax-tpl-old.mcs b/loader/tonyhax-tpl-old.mcs
new file mode 100644
index 0000000..50c3fa9
Binary files /dev/null and b/loader/tonyhax-tpl-old.mcs differ
diff --git a/tmp/og-tonyhax.0JX/loader/tonyhax-tpl.mcs b/loader/tonyhax-tpl.mcs
index 50c3fa9..0aab208 100644
Binary files a/tmp/og-tonyhax.0JX/loader/tonyhax-tpl.mcs and b/loader/tonyhax-tpl.mcs differ
