diff --git a/tmp/og-tonyhax.0bp/loader/Makefile b/loader/Makefile
index f121ebf..955f671 100644
--- a/tmp/og-tonyhax.0bp/loader/Makefile
+++ b/loader/Makefile
@@ -2,6 +2,7 @@
 # Thanks to whoever made https://devhints.io/makefile!
 
 include ../variables.mk
+include ../variables-shared.mk
 
 LOADER_AUTOGEN := orca.inc
 LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
@@ -32,7 +33,7 @@ secondary.elf: secondary.ld $(LOADER_OBJECTS)
 tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
 	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
 
-BESLEM-99999TONYHAX: tonyhax.mcs
+HAX: tonyhax.mcs
 	bash ../util/mcs2raw.sh tonyhax.mcs
 
 tonyhax.exe: secondary.elf
diff --git a/loader/Makefile.ff9 b/loader/Makefile.ff9
new file mode 100644
index 0000000..28c53f8
--- /dev/null
+++ b/loader/Makefile.ff9
@@ -0,0 +1,40 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk
+include ../variables-shared.mk
+
+LOADER_AUTOGEN := orca.inc
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) FF9 tonyhax-ff9.mcs *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary-ff9.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary-ff9.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl-ff9.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl-ff9.mcs tonyhax-ff9.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax-ff9.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.freepsxboot b/loader/Makefile.freepsxboot
new file mode 100644
index 0000000..53df243
--- /dev/null
+++ b/loader/Makefile.freepsxboot
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.freepsxboot
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.rom b/loader/Makefile.rom
new file mode 100644
index 0000000..d036c91
--- /dev/null
+++ b/loader/Makefile.rom
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.rom
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.tocperfect b/loader/Makefile.tocperfect
new file mode 100644
index 0000000..572f600
--- /dev/null
+++ b/loader/Makefile.tocperfect
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.tocperfect
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.xstation b/loader/Makefile.xstation
new file mode 100644
index 0000000..47d55ac
--- /dev/null
+++ b/loader/Makefile.xstation
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.xstation
+include ../variables-shared.mk
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/ap-bypass.c b/loader/ap-bypass.c
new file mode 100644
index 0000000..91c131b
--- /dev/null
+++ b/loader/ap-bypass.c
@@ -0,0 +1,1747 @@
+
+#include "bios.h"
+//#include "debugscreen.h"
+#include "str.h"
+#include "ap-bypass.h"
+
+bool cheat_engine_installed;
+
+uint8_t gs_code_type;
+
+int32_t code_address_ram_location = 0xD000;
+int32_t code_compare_ram_location = 0xD004;
+int32_t code_enable_ram_location = 0xD00C;  
+
+void clear_gs_code_line_ram () {
+	bzero((void*)0xD000, 0xF78); // 0xD000-0xDF78 are to be zeroed out to ensure correct parsing by the cheat engine (used for gs codes loaded via memcard AND for APv2 bypasses). 0xDF80 is used to contain BIOS patches so we stop 2 bytes previous to it. Every BIOS besides v3.0 has enough garbage in this 'reserved' area to break the cheat engine if we don't do this. Previously this zero-out was always done regardless of if the gameshark feature was actually being used. Now this is only done if the gameshark engine is active OR if this is an anti-piracy game to fix issue 39: https://github.com/alex-free/tonyhax/issues/39
+}
+
+void add_8bit_code(const uint32_t gs1, const uint8_t gs2, const uint8_t gs_code_type) {
+	if(code_address_ram_location == 0xD000)
+		clear_gs_code_line_ram(); // before writing first code line clear RAM
+
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 1);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_16bit_code(const uint32_t gs1, const uint16_t gs2, const uint8_t gs_code_type) {
+
+	if(code_address_ram_location == 0xD000)
+		clear_gs_code_line_ram(); // before writing first code line clear RAM
+
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 2);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+// size optimization wrapper, instead of specifying 0xD0 or 0x80 each time we add a code via built-in ap bypass system
+void add_80_code(const uint32_t gs1, const uint16_t gs2) {
+	add_16bit_code(gs1, gs2, 0x80);
+}
+
+void add_D0_code(const uint32_t gs1, const uint16_t gs2) {
+	add_16bit_code(gs1, gs2, 0xD0);
+}
+
+void install_cheat_engine() {
+// generate with `scripts/stealth-engine-xxd.sh` after compiling .EXE file with No $ PSX Emu Assembler
+const unsigned char cheat_engine_v1_0_4[] = {
+0xe0, 0xff, 0xbd, 0x27, 0x00, 0x00, 0xa4, 0xaf,
+  0x04, 0x00, 0xa5, 0xaf, 0x08, 0x00, 0xa6, 0xaf, 0x0c, 0x00, 0xa7, 0xaf,
+  0x00, 0x00, 0x04, 0x3c, 0x00, 0xd0, 0x84, 0x34, 0x00, 0x00, 0x00, 0x00,
+  0x0c, 0x00, 0x86, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0xc0, 0x10,
+  0xd0, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x00, 0xc7, 0x10,
+  0xd1, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x00, 0xc7, 0x10,
+  0xd2, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x61, 0x00, 0xc7, 0x10,
+  0xd3, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0xc7, 0x10,
+  0xe0, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0xc7, 0x10,
+  0xe1, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0xc7, 0x10,
+  0xe2, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0xc7, 0x10,
+  0xe3, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0xc7, 0x10,
+  0x80, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc7, 0x10,
+  0x30, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0xc7, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00,
+  0x73, 0x00, 0xc7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x07, 0x34,
+  0x1c, 0x00, 0x86, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0xc7, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa0, 0x10, 0x00, 0x84, 0x24,
+  0xcf, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94,
+  0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa4,
+  0x10, 0x00, 0x84, 0x24, 0xc8, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+  0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00, 0xe3, 0xff, 0xc5, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0xbe, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0xd9, 0xff, 0xc5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24,
+  0xb4, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90,
+  0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90,
+  0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xc5, 0x14, 0x00, 0x00, 0x00, 0x00,
+  0x20, 0x00, 0x84, 0x24, 0xaa, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+  0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00, 0xc5, 0xff, 0xc5, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0xa0, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x94, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x88, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x7c, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0x2b, 0x38, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0xff, 0xe0, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x84, 0x24, 0x70, 0xff, 0x00, 0x18,
+  0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x85, 0x90, 0x10, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa0, 0x20, 0x00, 0x84, 0x24,
+  0x69, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x85, 0x94,
+  0x10, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa4,
+  0x20, 0x00, 0x84, 0x24, 0x62, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xa4, 0x8f, 0x04, 0x00, 0xa5, 0x8f, 0x08, 0x00, 0xa6, 0x8f,
+  0x0c, 0x00, 0xa7, 0x8f, 0x20, 0x00, 0xbd, 0x27, 0x01, 0x00, 0x1a, 0x3c,
+  0xfc, 0xcf, 0x5a, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x03,
+  0x00, 0x00, 0x00, 0x00
+};
+
+	//debug_write("Installing MottZilla AP Engine");
+	memcpy((void*)0xC000, (void*)cheat_engine_v1_0_4, sizeof(cheat_engine_v1_0_4)); // Copy MottZilla's cheat engine assembly binary to 0xC000
+	const uint32_t b0_jump = (*(uint32_t*)0xB4) & 0xFFFF;
+	//debug_write("Got jump address for B0 functions : %x", (uint32_t) b0_jump);
+	const uint32_t b0_base = (*(uint32_t*)(b0_jump + 4)) & 0xFFFF;
+	//debug_write("Got base address for B0 table : %x", (uint32_t) b0_base);
+	const uint32_t b0_entry = b0_base + (0x17 * 4);
+	//debug_write("Got B0 table entry address : %x", (uint32_t) b0_entry);
+	const uint32_t old_table_val = *(uint32_t*) b0_entry;
+	//debug_write("B0 table entry to modify has the original contents : %x", (uint32_t) old_table_val);
+	memcpy((void*)0xCFFC, (void*)&old_table_val, sizeof(old_table_val)); // Copy the original 32 bit number of the B table entry we want to modify to 0xCFFC
+	const uint16_t redirect = 0xC000;
+	memcpy((void*)b0_entry, &redirect, 2); // Write the value 0xC000 to table entry we want to modify
+   //for(volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+   cheat_engine_installed = 1;
+}
+
+void activate_anti_anti_piracy(const char * bootfile, const int32_t load_addr) 
+{
+	int32_t ver_check;
+	uint8_t ver_check_val;
+	int8_t bootfile_len = strlen(bootfile);
+
+	// Aprip code type constants
+	const uint16_t readtoc_compare_val = 0x001E;
+	const uint16_t readtoc_patch_val = 0x0000;
+
+	// Many pre-existing 'skip mod check' or 'force routine ok' type codes from back in the day seem to share these values, so they are a const
+	const uint16_t common_routine_return_compare_val = 0x1040;
+	const uint16_t common_routine_return_patch_val = 0x1000;
+
+	if(bootfile_len > 13) {
+		bootfile = &bootfile[bootfile_len-13]; // XXXX_XXX.XX;1 , we are only changing the locally declared bootfile here, not in secondary.c.
+		//debug_write("Stripped Bootfile: %s", bootfile);
+	} else if(bootfile_len < 13) {
+		return; 
+		// Speed optimization. All anti-piracy games currently have a bootfile name that is at least 13 uchars long when stripped. So if the bootfile happens to have something like 'MAIN.EXE;1' (which is 10 in length), we already know not to bother even checking for an anti-piracy bootfile match to apply codes for (which takes time in itself to do as well).
+	}
+
+// Animetic Story Game 1: Card Captor Sakura
+   	if(
+	((strcmp("SLPS_018.30;1", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SLPS_018.31;1", bootfile)) == 0) // Japan Disc 2
+	) { // 2 disc game
+		/*
+		D001516A 1040
+		8001516A 1000
+		code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_c.shtml
+    	*/
+    	add_D0_code(0x8001516A, common_routine_return_compare_val);
+		add_80_code(0x8001516A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Alundra 2
+	((strcmp("SCPS_101.15;1", bootfile)) == 0) { // Japan
+		/*
+		D004E91A 1040
+		8004E91A 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+    	*/
+    	add_D0_code(0x8004E91A, common_routine_return_compare_val);
+		add_80_code(0x8004E91A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Arc The Lad III
+	(
+	((strcmp("SCPS_101.06;1", bootfile)) == 0) // Japan Rev 0/Rev 1 Disc 1
+	|| ((strcmp("SCPS_101.07;1", bootfile)) == 0) // Japan Rev 0/Rev 1 Disc 2
+	) {
+		ver_check = (load_addr + 0x20); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0x8C)) // Rev 0
+		{
+			/*
+			D0021DF6 1040
+			80021DF6 1000
+			code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+    		*/
+	    	add_D0_code(0x80021DF6, common_routine_return_compare_val);
+			add_80_code(0x80021DF6, common_routine_return_patch_val);
+    		install_cheat_engine();
+    	} else { // Rev 1
+ 			/*
+			D0022206 1040 my code via aprip gameshark code conversion
+			80022206 1000
+    		*/
+	    	add_D0_code(0x80022206, common_routine_return_compare_val);
+			add_80_code(0x80022206, common_routine_return_patch_val);
+    		install_cheat_engine();		
+    	}
+    } else if
+
+// Beatmania featuring Dreams Come True
+   	((strcmp("SLPM_865.97;1", bootfile)) == 0) { // Japan
+		/*
+		D012255C 001E
+		8012255C 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x8012255C, readtoc_compare_val);
+		add_80_code(0x8012255C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Beatmania Best Hits
+   	((strcmp("Slpm_865.96;1", bootfile)) == 0) { // Japan Rev 0/Rev 1
+		// not a typo, weird asf filename
+		/*
+		D0151448 001E
+		80151448 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x80151448, readtoc_compare_val);
+		add_80_code(0x80151448, readtoc_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Beat Mania: The Sound of Tokyo
+	((strcmp("SLPM_867.69;1", bootfile)) == 0) { // Japan
+    	/*
+		D0134C48 001E
+		80134C48 0000
+		my code to patch out readtoc
+    	*/
+	    add_D0_code(0x80134C48, readtoc_compare_val);
+		add_80_code(0x80134C48, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Beat Mania 6thMix + Core Remix
+	((strcmp("SLPM_870.12;1", bootfile)) == 0) { // Japan
+		/*
+		D0131B6C 001E
+		80131B6C 001A
+    	my code to patch out readtoc
+    	*/
+	    add_D0_code(0x80131B6C, readtoc_compare_val);
+		add_80_code(0x80131B6C, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Boku no Natsuyasumi: Summer Holiday 20th Century
+	((strcmp("SCPS_100.88;1", bootfile)) == 0) { // Japan
+		/*
+		D0068B30 001E
+		80068B30 0000
+    	my code to patch out readtoc
+    	*/
+	    add_D0_code(0x80068B30, readtoc_compare_val);
+		add_80_code(0x80068B30, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Breath of Fire IV
+   	((strcmp("SLPS_027.28;1", bootfile)) == 0) { // Japan / USA E3 2000 Beta Build
+		/*
+		D01D0698 001E
+		801D0698 0000
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x801D0698, readtoc_compare_val);
+		add_80_code(0x801D0698, readtoc_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Capcom vs. SNK: Millennium Fight 2000 Pro
+   	((strcmp("SLPM_870.53;1", bootfile)) == 0) { // Japan
+		/*
+		D0051B60 001E
+		80051B60 0000
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x80051B60, readtoc_compare_val);
+		add_80_code(0x80051B60, readtoc_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Chase The Express
+   	(
+	((strcmp("SCPS_101.09;1", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SCPS_101.10;1", bootfile)) == 0) // Japan Disc 2
+	|| ((strcmp("PAPX_901.06;1", bootfile)) == 0) // Japan Demo 1
+	|| ((strcmp("PCPX_961.89;1", bootfile)) == 0) // Japan Demo 2
+	) {
+		/*
+		D00EA6DE 1040
+		800EA6DE 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_c.shtml
+    	*/
+	    add_D0_code(0x800EA6DE, common_routine_return_compare_val);
+		add_80_code(0x800EA6DE, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Crash Bash
+  	((strcmp("SCUS_945.70;1", bootfile)) == 0) { // USA
+		/*
+		D002D51E 1040
+		8002D51E 1000
+		code from GameHacking: https://gamehacking.org/game/88640, skips mod check
+    	*/
+	    add_D0_code(0x8002D51E, common_routine_return_compare_val);
+		add_80_code(0x8002D51E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if 
+
+   	((strcmp("SCPS_101.40;1", bootfile)) == 0) { // Japan
+		/*
+		D002D7EE 1040
+		8002D7EE 1000
+		code from GameHacking: https://gamehacking.org/game/93827, skips mod check
+    	*/
+	    add_D0_code(0x8002D7EE, common_routine_return_compare_val);
+		add_80_code(0x8002D7EE, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Crash Bandicoot Racing
+   	((strcmp("SCPS_101.18;1", bootfile)) == 0) { // Japan
+		/*
+		D001259A 1040
+		8001259A 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml (yes it's on the wrong lettered page)
+    	*/
+	    add_D0_code(0x8001259A, common_routine_return_compare_val);
+		add_80_code(0x8001259A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("PCPX_961.83;1", bootfile)) == 0) { // Japan Demo
+		/*
+    	D001255E 1040
+    	8001255E 1040
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x8001255E, common_routine_return_compare_val);
+		add_80_code(0x8001255E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Cool Boarders 2001
+   	((strcmp("SCUS_946.25;1", bootfile)) == 0) { // USA Demo
+		/*
+		D00B35B0 001E
+		800B35B0 0000
+		code generated via aprip
+    	*/
+	    add_D0_code(0x800B35B0, readtoc_compare_val);
+		add_80_code(0x800B35B0, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.97;1", bootfile)) == 0) { // USA
+		/*
+		D00B35B8 001E
+		800B35B8 0000
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x800B35B8, readtoc_compare_val);
+		add_80_code(0x800B35B8, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Best Hits
+   	((strcmp("SLPM_866.93;1", bootfile)) == 0) { // Japan
+		/*
+		D0102FA0 001E
+		80102FA0 0000
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x80102FA0, readtoc_compare_val);
+		add_80_code(0x80102FA0, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Disney's Rave
+   	((strcmp("SLPM_866.67;1", bootfile)) == 0) { // Japan
+		/*
+		D0192248 001E
+		80192248 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x80192248, readtoc_compare_val);
+		add_80_code(0x80192248, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Extra Mix
+   	((strcmp("SLPM_868.31;1", bootfile)) == 0) { // Japan
+		/*
+		D00EB364 001E
+		800EB364 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x800EB364, readtoc_compare_val);
+		add_80_code(0x800EB364, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution 2nd Remix
+   	((strcmp("SLPM_862.52;1", bootfile)) == 0) { // Dance Dance Revolution 2nd Remix Append Club Vol 1 and Dance Dance Revolution 2nd Remix Append Club Vol 2 discs are booted with a 'disc change' feature within Dance Dance Revolution 2nd Remix (which is a 'base' disc when booting the others, kind of like DLC).
+		/*
+		Dance Dance Revolution 2nd Remix:
+		D00200A6 1040
+		800200A6 1000
+		*/
+	    add_D0_code(0x800200A6, common_routine_return_compare_val);
+		add_80_code(0x800200A6, common_routine_return_patch_val);
+		/*
+		D0020D64 FFF2
+		80020D64 0001
+		*/
+    	add_D0_code(0x80020D64, 0xFFF2);
+    	add_80_code(0x80020D64, 0x0001);
+		/*
+		D01C1BE4 FFF2
+		801C1BE4 0001
+		*/
+    	add_D0_code(0x801C1BE4, 0xFFF2);
+    	add_80_code(0x801C1BE4, 0x0001);
+
+		/*
+		D01C1C7A 0C07
+		801C1C7A 3002
+		*/
+    	add_D0_code(0x801C1C7A, 0x0C07);
+    	add_80_code(0x801C1C7A, 0x3002);
+		/*
+		D01C2936 1040
+		801C2936 1000
+		*/
+    	add_D0_code(0x801C2936, common_routine_return_compare_val);
+    	add_80_code(0x801C2936, common_routine_return_patch_val);
+		/*
+		Dance Dance Revolution 2nd Remix Append Club Vol 1
+		D01C2A18 0C92
+		801C2A18 0AA7
+		*/
+    	add_D0_code(0x801C2A18, 0x0C92);
+    	add_80_code(0x801C2A18, 0x0AA7);
+		/*
+		D01C2EA2 1040
+		801C2EA2 1000
+		*/
+    	add_D0_code(0x801C2EA2,common_routine_return_compare_val);
+    	add_80_code(0x801C2EA2, common_routine_return_patch_val);
+
+		/*
+		Dance Dance Revolution 2nd Remix Append Club Vol 2
+		D01C2F32 1040
+		801C2F32 1000
+		*/
+    	add_D0_code(0x801C2F32, common_routine_return_compare_val);
+    	add_80_code(0x801C2F32, common_routine_return_patch_val);
+		/*
+		D01C2AA8 0CB6
+		801C2AA8 0ACB
+		*/
+    	add_D0_code(0x801C2AA8, 0x0CB6);
+    	add_80_code(0x801C2AA8, 0x0ACB);
+		// codes are from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml .
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: 3rd Mix
+   	((strcmp("SLPM_865.03;1", bootfile)) == 0) { // Japan
+		/*
+		D00C4260 001E 
+		800C4260 0000
+		my code generated via aprip
+    	*/
+    	add_D0_code(0x800C4260, readtoc_compare_val);
+    	add_80_code(0x800C4260, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: 4th Mix
+   	((strcmp("SLPM_867.52;1", bootfile)) == 0) { // Japan
+		/*
+		D00EB3E4 001E
+		800EB3E4 0000
+		my code generated via aprip
+    	*/
+    	add_D0_code(0x800EB3E4, readtoc_compare_val);
+    	add_80_code(0x800EB3E4, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: 5th Mix
+   	((strcmp("SLPM_868.97;1", bootfile)) == 0) { // Japan
+		/*
+		D0177140 001E 
+		80177140 0000
+		my code generated via aprip
+    	*/
+    	add_D0_code(0x80177140, readtoc_compare_val);
+    	add_80_code(0x80177140, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dancing Stage featuring Dreams Come True
+   	((strcmp("SLPM_865.05;1", bootfile)) == 0) { // Japan
+		/*
+		D019245C 001E
+		8019245C 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+    	add_D0_code(0x8019245C, readtoc_compare_val);
+    	add_80_code(0x8019245C, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dancing Stage featuring True Kiss Destination
+   	((strcmp("SLPM_864.11;1", bootfile)) == 0) { // Japan
+		/*
+		D019117A 1040
+		8019117A 1000
+		code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+    	add_D0_code(0x8019117A, common_routine_return_compare_val);
+    	add_80_code(0x8019117A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dino Crisis
+	((strcmp("SLUS_009.22;1", bootfile)) == 0) { // USA Rev 0/USA Rev 1
+		ver_check = (load_addr + 0x61); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if(ver_check_val == 0xD0) { // Rev 0
+			/*
+			D0149004 959C
+			80149004 9E64
+			Found independently by MottZilla, but actually turns out to be the same code by Epson found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+			*/
+  		  	add_D0_code(0x80149004, 0x959C);
+  		  	add_80_code(0x80149004, 0x9E64);
+			install_cheat_engine();
+		} else { // Rev 1
+			/*
+			D0148004 8658
+			80148004 8F20
+			my code, the anti-piracy table just moved memory addresses between versions :)
+			*/
+ 			add_D0_code(0x80148004, 0x8658);
+ 			add_80_code(0x80148004, 0x8F20);
+			install_cheat_engine();
+    	}
+	} else if
+
+   	((strcmp("SLPS_021.80;1", bootfile)) == 0) { // Japan
+		/*
+		D0149004 959C
+		80149004 9E64
+		Found independently by MottZilla, but actually turns out to be the same code by Epson found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml . Yes this is the same code as the USA rev 0 one.
+		*/
+  		add_D0_code(0x80149004, 0x959C);
+  		add_80_code(0x80149004, 0x9E64);
+		install_cheat_engine();
+    } else if
+
+// Dino Crisis 2
+   	((strcmp("SLPM_866.27;1", bootfile)) == 0) { // Japan
+	  	/*
+		D00D7714 001E
+		800D7714 0000
+		my code via aprip to disable readtoc
+		*/
+		add_D0_code(0x800D7714, readtoc_compare_val);
+		add_80_code(0x800D7714, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_805.73;1", bootfile)) == 0) { // Japan Demo
+	  	/*
+		D00CB104 001E
+		800CB104 0000
+		my codevia aprip to disable readtoc
+		*/
+		add_D0_code(0x800CB104, readtoc_compare_val);
+		add_80_code(0x800CB104, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Disney's The Emperor's New Groove
+   	((strcmp("SCUS_945.71;1", bootfile)) == 0) { // USA
+	  	/*
+		D0063004 001E
+		80063004 0000
+		my code via aprip to disable readtoc
+		*/
+		add_D0_code(0x80063004, readtoc_compare_val);
+		add_80_code(0x80063004, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCES_030.10;1", bootfile)) == 0) { // Europe
+  		/*
+		D006351C 001E
+		8006351C 0000
+		my code via aprip to disable readtoc
+		*/
+		add_D0_code(0x8006351C, readtoc_compare_val);
+		add_80_code(0x8006351C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Exciting Bass 2
+   	((strcmp("SLPM_862.95;1", bootfile)) == 0) { // Japan
+		/*
+		D00177BA 1040
+		800177BA 1000	
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_e.shtml
+  		*/
+  		add_D0_code(0x800177BA, common_routine_return_compare_val);
+  		add_80_code(0x800177BA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Exciting Bass 3
+   	((strcmp("SLPM_867.29;1", bootfile)) == 0) { // Japan
+		/*
+		D00B9170 001E
+		800B9170 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x800B9170, readtoc_compare_val);
+		add_80_code(0x800B9170, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Gekitotsu Toma L'Arc - L'Arc en Ciel vs Tomarunner
+   	((strcmp("SCPS_101.34;1", bootfile)) == 0) { // Japan
+		/*
+		D0195D9C 001E
+		80195D9C 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x80195D9C, readtoc_compare_val);
+		add_80_code(0x80195D9C, readtoc_patch_val);
+  		install_cheat_engine();
+    } else if
+
+// Glint Glitters
+   	((strcmp("SLPM_862.00;1", bootfile)) == 0) { // Japan
+		/*
+		D01B3188 001E
+		801B3188 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x801B3188, readtoc_compare_val);
+		add_80_code(0x801B3188, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Goo! Goo! Soundry
+   	((strcmp("SLPM_862.50;1", bootfile)) == 0) { // Japan
+		/*
+		D0055278 001E
+		80055278 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x80055278, readtoc_compare_val);
+		add_80_code(0x80055278, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Grind Session
+   	((strcmp("SCUS_945.68;1", bootfile)) == 0) { // USA
+		/*
+		D0014274 52A9
+		80014274 50BE
+		code 1 of 2 by 'TheVoice' found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+    	*/
+  		add_D0_code(0x80014274, 0x52A9);
+  		add_80_code(0x80014274, 0x50BE);
+		/*
+		D00146FE 1040
+		800146FE 1000
+		code 2 of 2 by 'TheVoice' found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+		*/
+  		add_D0_code(0x800146FE, common_routine_return_compare_val);
+  		add_80_code(0x800146FE, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Guitar Freaks
+   	((strcmp("SLPM_862.65;1", bootfile)) == 0) { // Japan
+		/*
+		D001654E 1040
+		8001654E 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+    	*/
+  		add_D0_code(0x8001654E, common_routine_return_compare_val);
+  		add_80_code(0x8001654E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Harlem Beat: You're The One
+   	((strcmp("SLPM_863.29;1", bootfile)) == 0) { // Japan
+		/*
+		D01A411E 1040
+		801A411E 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x801A411E, common_routine_return_compare_val);
+  		add_80_code(0x801A411E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Hyper Value 2800: Hanafuda
+   	((strcmp("SLPM_864.17;1", bootfile)) == 0) { // Japan
+		/*
+		D00A1188 001E
+		800A1188 0000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x800A1188, readtoc_compare_val);
+  		add_80_code(0x800A1188, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Hyper Value 2800: Mahjong
+   	((strcmp("SLPM_862.92;1", bootfile)) == 0) { // Japan
+		/*
+		D00A0186 1040
+		800A0186 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x800A0186, common_routine_return_compare_val);
+  		add_80_code(0x800A0186, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// i-mode mo Issho: Doko Demo Issho Tsuika Disc
+    ((strcmp("SCPS_101.41;1", bootfile)) == 0) { // Japan
+        /*
+        D01698B4 001E
+        801698B4 0000
+        code generated via aprip by M4x1mumReZ: https://gbatemp.net/members/m4x1mumrez.610331/
+        */
+        add_D0_code(0x801698B4, readtoc_compare_val);
+        add_80_code(0x801698B4, readtoc_patch_val);
+        install_cheat_engine();
+    } else if
+
+// Jikkyou Powerful Pro Yakyuu '99 Ketteiban
+   	((strcmp("SLPM_864.33;1", bootfile)) == 0) { // Japan
+  		/*
+		D016B4D8 001E
+		8016B4D8 0000
+		my code to patch out readtoc via aprip
+		*/
+        add_D0_code(0x8016B4D8, readtoc_compare_val);
+        add_80_code(0x8016B4D8, readtoc_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Jikkyou Powerful Pro Yakyuu '99: Kaimakuban
+   	((strcmp("SLPM_862.53;1", bootfile)) == 0) { // Japan
+		/*
+		D016B268 001E
+		8016B268 0000
+		my code to patch out readtoc via aprip
+		*/
+        add_D0_code(0x8016B268, readtoc_compare_val);
+        add_80_code(0x8016B268, readtoc_patch_val);
+		install_cheat_engine();
+	} else if
+
+// JoJo's Bizarre Adventure
+   	((strcmp("SLPS_022.36;1", bootfile)) == 0) { // Japan
+		/*
+		D0035C48 D91E
+		80035C48 D733
+		code 1 of 2 found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x80035C48, 0xD91E);
+  		add_80_code(0x80035C48, 0xD733);
+  		/*
+		D00360D2 1040
+		800360D2 1000
+		code 2 of 2 found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x800360D2, common_routine_return_compare_val);
+  		add_80_code(0x800360D2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Koko Hore! Pukka
+	((strcmp("SCPS_101.33;1", bootfile)) == 0) { // Japan
+		/*
+		D00A341C 001E
+		800A341C 0000
+		code generated via aprip by https://gbatemp.net/members/m4x1mumrez.610331/
+    	*/
+  		add_D0_code(0x800A341C, readtoc_compare_val);
+  		add_80_code(0x800A341C, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Koneko mo Issho
+   	((strcmp("SCPS_101.27;1", bootfile)) == 0) { // Japan
+		/*
+		D016957C 001E
+		8016957C 0000
+		my code generated via aprip
+		*/
+  		add_D0_code(0x8016957C, readtoc_compare_val);
+  		add_80_code(0x8016957C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Legend Of Dragoon
+   	(
+	((strcmp("SCPS_101.19;1", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("scps_101.20;1", bootfile)) == 0) // Japan Disc 2 (weird ass filename not a typo)
+	|| ((strcmp("scps_101.21;1", bootfile)) == 0) // Japan Disc 3 (weird ass filename not a typo)
+	|| ((strcmp("scps_101.22;1", bootfile)) == 0) // Japan Disc 4 (weird ass filename not a typo)
+	) {
+		/*
+		D01BF172 1040
+		801BF172 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+    	*/
+  		add_D0_code(0x801BF172, common_routine_return_compare_val);
+  		add_80_code(0x801BF172, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCUS_944.91;1", bootfile)) == 0) // USA Disc 1
+	|| ((strcmp("SCUS_945.84;1", bootfile)) == 0) // USA Disc 2
+	|| ((strcmp("SCUS_945.85;1", bootfile)) == 0) // USA Disc 3
+	|| ((strcmp("SCUS_945.86;1", bootfile)) == 0) // USA Disc 4
+	) {
+		/*
+		801BF6F6 1040
+		801BF6F6 1000 
+		my code via aprip's gameshark conversion
+   		*/
+  		add_D0_code(0x801BF6F6, common_routine_return_compare_val);
+  		add_80_code(0x801BF6F6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	(
+	(strcmp("SCES_030.43;1", bootfile)) == 0) // Europe Disc 1
+	|| ((strcmp("SCES_130.43;1", bootfile)) == 0) // Europe Disc 2
+	|| ((strcmp("SCES_230.43;1", bootfile)) == 0) // Europe Disc 3
+	|| ((strcmp("SCES_330.43;1", bootfile)) == 0) // Europe Disc 4
+	) {
+		/*
+		D01C0892 1040
+		801C0892 1000
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0892, common_routine_return_compare_val);
+  		add_80_code(0x801C0892, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCES_030.44;1", bootfile)) == 0) // France Disc 1
+	|| ((strcmp("SCES_130.44;1", bootfile)) == 0) // France Disc 2
+	|| ((strcmp("SCES_230.44;1", bootfile)) == 0) // France Disc 3
+	|| ((strcmp("SCES_330.44;1", bootfile)) == 0) // France Disc 4
+	) {
+		/*
+		D01C0872 1040
+		801C0872 1040
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0872, common_routine_return_compare_val);
+  		add_80_code(0x801C0872, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCES_030.45;1", bootfile)) == 0) // Germany Disc 1
+	|| ((strcmp("SCES_130.45;1", bootfile)) == 0) // Germany Disc 2
+	|| ((strcmp("SCES_230.45;1", bootfile)) == 0) // Germany Disc 3
+	|| ((strcmp("SCES_330.45;1", bootfile)) == 0)// Germany Disc 4
+	) { 
+		/*
+		D01C082E 1040
+		801C082E 1000
+		my code via aprip's gameshark conversion
+  		*/
+  		add_D0_code(0x801C082E, common_routine_return_compare_val);
+  		add_80_code(0x801C082E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SCES_030.46;1", bootfile)) == 0) // Italian Disc 1
+	|| ((strcmp("SCES_130.46;1", bootfile)) == 0) // Italian Disc 2
+	|| ((strcmp("SCES_230.46;1", bootfile)) == 0) // Italian Disc 3
+	|| ((strcmp("SCES_330.46;1", bootfile)) == 0)// Italian Disc 4
+	) {
+		/*
+		D01C0826 1040
+		801C0826 1000
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0826, common_routine_return_compare_val);
+  		add_80_code(0x801C0826, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Legend Of Mana
+   	((strcmp("SLPS_021.70;1", bootfile)) == 0) { // Japan
+   		//debug_write("Detected Legend Of Mana");
+		/*
+		D0050ECA 1040 
+		80050ECA 1000
+		code 1 of 2 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+  		add_D0_code(0x80050ECA, common_routine_return_compare_val);
+  		add_80_code(0x80050ECA, common_routine_return_patch_val);
+    	/*
+		D00360D2 1040
+		800360D2 1000
+		code 2 of 2 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+  		add_D0_code(0x800360D2, common_routine_return_compare_val);
+  		add_80_code(0x800360D2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Love Hina: Ai wa Kotoba no Naka ni / Love Hina 2: Kotoba wa Konayuki no You ni
+   	(
+	((strcmp("SLPM_866.52;1", bootfile)) == 0) // Love Hina: Ai wa Kotoba no Naka ni
+	|| ((strcmp("SLPM_866.77;1", bootfile)) == 0) // Love Hina 2: Kotoba wa Konayuki no You ni
+	) { 
+		// Same code works for both games
+		/*
+		 D01011C0 001E
+		 801011C0 0000
+		code generated via APrip by https://gbatemp.net/members/m4x1mumrez.610331/
+    	*/
+ 		add_D0_code(0x801011C0, readtoc_compare_val);
+ 		add_80_code(0x801011C0, readtoc_patch_val);
+ 		install_cheat_engine();
+    } else if
+
+// Marvel vs. Capcom: Clash of Super Heroes
+   	(
+	((strcmp("SLPS_023.68;1", bootfile)) == 0) // Japan
+	|| ((strcmp("SLPM_805.08;1", bootfile)) == 0) // Japan Demo
+	) {
+		/*
+		D00F0C3A 1040
+		800F0C3A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x800F0C3A, common_routine_return_compare_val);
+  		add_80_code(0x800F0C3A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Medievil II
+   	((strcmp("SCUS_945.64;1", bootfile)) == 0) {
+		/*
+		D0098804 023A
+		80098806 1000
+		code via https://gamehacking.org/game/89269
+		*/
+  		add_D0_code(0x80098804, 0x023A);
+  		add_80_code(0x80098806, 0x1000);
+		install_cheat_engine();
+    } else if
+
+// MLB 2002 Demo, MLB 2002, MLB 2003 Demo, MLB 2003, MLB 2004
+   	(
+	((strcmp("SCUS_946.48;1", bootfile)) == 0) // MLB 2002 USA Demo
+	|| ((strcmp("SCUS_946.38;1", bootfile)) == 0) // MLB 2002 USA
+	|| ((strcmp("SCUS_946.72;1", bootfile)) == 0) // MLB 2003 USA Demo
+	|| ((strcmp("SCUS_946.53;1", bootfile)) == 0) // MLB 2003 USA
+	|| ((strcmp("SCUS_946.89;1", bootfile)) == 0) // MLB 2004 USA
+	) {
+		/*
+		D0028DB4 001E
+		80028DB4 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80028DB4, readtoc_compare_val);
+  		add_80_code(0x80028DB4, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// My Garden
+   	((strcmp("SLPS_022.13;1", bootfile)) == 0) { // Japan
+		/*
+		D009E212 1040
+		8009E212 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x8009E212, common_routine_return_compare_val);
+  		add_80_code(0x8009E212, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2001 and NBA Shootout 2001 Demo
+   	((strcmp("SCUS_945.81;1", bootfile)) == 0) { // this game is nuts. Seriously what the fuck is this. The demo and retail versions share not only the same executable filename, the demo executable file is the exact same with 0 diffs compared to the retail version. I guess retail functionallity is being enabled by some other file in track 01 (which do in fact differ between the demo and retail versions). EVEN FUCKING WORSE is that the demo version has serial number SCUS_945.82, but the boot file is SCUS_945.81! For now we enable both demo and retail codes for both versions to ensure it boots, since we can't detect this off of bootfile alone. To do this in a less ugly way we would need to find the file in track 01 that differs (to enable retail functionallity) and then diff that in memory.
+		/*
+		D01D1340 001E
+		801D1340 0000
+		my code generated via aprip (USA)
+		*/
+		add_D0_code(0x801D1340, readtoc_compare_val);
+		add_80_code(0x801D1340, readtoc_patch_val);
+		/*
+		D01CFD68 001E
+		801CFD68 0000
+		my code generated via aprip (USA Demo)
+		*/
+		add_D0_code(0x801CFD68, readtoc_compare_val);
+		add_80_code(0x801CFD68, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2002 Demo
+   	((strcmp("SCUS_946.60;1", bootfile)) == 0) { // USA
+		/*
+		D01D0FF4 001E
+		801D0FF4 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D0FF4, readtoc_compare_val);
+		add_80_code(0x801D0FF4, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2002
+   	((strcmp("SCUS_946.41;1", bootfile)) == 0) { // USA
+		/*
+		D01D2724 001E
+		801D2724 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D2724, readtoc_compare_val);
+		add_80_code(0x801D2724, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2003
+   	((strcmp("SCUS_946.73;1", bootfile)) == 0) { // USA
+		/*
+		D01D2860 001E
+		801D2860 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D2860, readtoc_compare_val);
+		add_80_code(0x801D2860, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2004
+   	((strcmp("SCUS_946.91;1", bootfile)) == 0) { // USA
+		/*
+		D01D2928 001E
+		801D2928 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D2928, readtoc_compare_val);
+		add_80_code(0x801D2928, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NCAA FinalFour 2001
+   	((strcmp("SCUS_945.79;1", bootfile)) == 0) { // USA
+		/*
+		D005B6A8 001E
+		8005B6A8 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x8005B6A8, readtoc_compare_val);
+  		add_80_code(0x8005B6A8, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NCAA GameBreaker 2001
+   	(
+	((strcmp("SCUS_945.74;1", bootfile)) == 0) // NCAA GameBreaker 2001 USA
+	|| ((strcmp("SCUS_945.73;1", bootfile)) == 0) // NCAA GameBreaker 2001 USA Demo
+	) {
+		/*
+		D0112338 001E
+		80112338 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80112338, readtoc_compare_val);
+  		add_80_code(0x80112338, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2001
+   	((strcmp("SCUS_945.75;1", bootfile)) == 0) { // USA
+		/*
+		D0112404 001E
+		80112404 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80112404, readtoc_compare_val);
+  		add_80_code(0x80112404, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2001 Demo
+   	((strcmp("SCUS_945.76;1", bootfile)) == 0) { // USA
+		/*
+		D0112388 001E
+		80112388 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80112388, readtoc_compare_val);
+  		add_80_code(0x80112388, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2002
+   	((strcmp("SCUS_946.39;1", bootfile)) == 0) { // USA
+		/*
+		D0032640 001E
+		80032640 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80032640, readtoc_compare_val);
+  		add_80_code(0x80032640, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2003, NFL GameDay 2004, and NFL GameDay 2005 (lmao they gave up?)
+   	(
+	((strcmp("SCUS_946.65;1", bootfile)) == 0) // NFL GameDay 2003 USA
+	|| ((strcmp("SCUS_946.90;1", bootfile)) == 0) // NFL GameDay 2004 USA
+	|| ((strcmp("SCUS_946.95;1", bootfile)) == 0) // NFL GameDay 2005 USA
+	) {
+		/*
+		D0032ACC 001E
+		80032ACC 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80032ACC, readtoc_compare_val);
+  		add_80_code(0x80032ACC, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NHL FaceOff 2001
+   	((strcmp("SCUS_945.77;1", bootfile)) == 0) { // USA
+		/*
+		D00F2470 001E
+		800F2470 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x800F2470, readtoc_compare_val);
+  		add_80_code(0x800F2470, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.78;1", bootfile)) == 0) { // USA Demo
+		/*
+		D00F1938 001E
+		800F1938 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x800F1938, readtoc_compare_val);
+  		add_80_code(0x800F1938, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Oha-Studio Dance Dance Revolution
+   	((strcmp("SLPM_866.03;1", bootfile)) == 0) { // Japan
+		/*
+		D00FAE58 001E
+		800FAE58 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+  		add_D0_code(0x800FAE58, readtoc_compare_val);
+  		add_80_code(0x800FAE58, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Ore no Ryouri
+   	((strcmp("SCPS_100.99;1", bootfile)) == 0) { // Japan
+		/*
+		D0031C1A 1040
+		80031C1A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x80031C1A, common_routine_return_compare_val);
+  		add_80_code(0x80031C1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pocket Jiman
+   	((strcmp("SCPS_101.04;1", bootfile)) == 0) { // Japan
+		/*
+		 D0126BDC 001E
+		 80126BDC 0000
+		 code by https://gbatemp.net/members/m4x1mumrez.610331/ generated with APrip
+		*/
+  		add_D0_code(0x80126BDC, readtoc_compare_val);
+  		add_80_code(0x80126BDC, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// PoPoLoCrois Monogatari II
+   	(
+	((strcmp("SCPS_101.12;1", bootfile)) == 0) // Japan Disc 1
+	|| ((strcmp("SCPS_101.13;1", bootfile)) == 0) // Japan Disc 2
+	|| ((strcmp("SCPS_101.14;1", bootfile)) == 0) // Japan Disc 3
+	) {
+		/*
+		 D00B2612 1040
+		 800B2612 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x800B2612, common_routine_return_compare_val);
+  		add_80_code(0x800B2612, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music: Animation Melody
+   	((strcmp("SLPM_865.92;1", bootfile)) == 0) { // Japan
+		/*
+		D009E7E8 001E
+		8009E7E8 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+  		add_D0_code(0x8009E7E8, readtoc_compare_val);
+  		add_80_code(0x8009E7E8, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music: Disney Tunes
+   	((strcmp("SLPM_866.70;1", bootfile)) == 0) { // Japan
+		/*
+		D008A45C 001E
+		8008A45C 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+  		add_D0_code(0x8008A45C, readtoc_compare_val);
+  		add_80_code(0x8008A45C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 2
+   	((strcmp("SLPM_862.94;1", bootfile)) == 0) { // Japan
+		/*
+		D0015342 1040
+		80015342 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+    	*/
+  		add_D0_code(0x80015342, common_routine_return_compare_val);
+  		add_80_code(0x80015342, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 5
+   	((strcmp("SLPM_869.37;1", bootfile)) == 0) { // Japan
+   		/*
+		D0048F34 001E
+		80048F34 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x80048F34, readtoc_compare_val);
+  		add_80_code(0x80048F34, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 6
+   	((strcmp("SLPM_870.89;1", bootfile)) == 0) { // Japan
+		/*
+		D004A24C 001E
+		8004A24C 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x8004A24C, readtoc_compare_val);
+  		add_80_code(0x8004A24C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Resident Evil 3: The Last Escape
+   	((strcmp("SLPS_023.00;1", bootfile)) == 0) { // Japan Rev 0/ Japan Rev 1
+		ver_check = (load_addr + 0x1B0); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0xF4)) // Rev 0
+		{
+			/*
+			D01840E2 1040
+			801840E2 1000
+			'skip check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+    		*/
+	    	add_D0_code(0x801840E2, common_routine_return_compare_val);
+			add_80_code(0x801840E2, common_routine_return_patch_val);
+    		install_cheat_engine();
+	    } else { // Rev 1
+			/*
+			D018418E 1040
+			8018418E 1000 
+			my code via aprip gameshark code conversion
+    		*/
+	    	add_D0_code(0x8018418E, common_routine_return_compare_val);
+			add_80_code(0x8018418E, common_routine_return_patch_val);
+    		install_cheat_engine();
+	    }
+	} else if
+
+   	((strcmp("SLPM_804.85;1", bootfile)) == 0) { // Japan Demo
+		/*
+		D01800E2 1040
+		801800E2 1000 
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x801800E2, common_routine_return_compare_val);
+		add_80_code(0x801800E2, common_routine_return_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Resident Evil Survivor
+   	((strcmp("SLPS_025.53;1", bootfile)) == 0) { // Japan
+		/*
+		D0017962 1040
+		80017962 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+    	*/
+  		add_D0_code(0x80017962, common_routine_return_compare_val);
+  		add_80_code(0x80017962, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SLUS_010.87;1", bootfile)) == 0) { // USA
+		/*
+		D001714E 1040
+		8001714E 1000
+		converted code via aprip
+    	*/
+  		add_D0_code(0x8001714E, common_routine_return_compare_val);
+  		add_80_code(0x8001714E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	(
+	((strcmp("SLES_027.32;1", bootfile)) == 0) // Europe
+	|| ((strcmp("SLES_027.44;1", bootfile)) == 0) // France
+	) {
+		/*
+		D001713E 1040
+		8001713E 1000
+		converted code via aprip
+    	*/
+  		add_D0_code(0x8001713E, common_routine_return_compare_val);
+  		add_80_code(0x8001713E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Robbit mon Dieu
+   	((strcmp("SCPS_101.03;1", bootfile)) == 0) { // Japan
+		/*
+		D001C646 1040
+		8001C646 1000
+		'skip mod check' code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8001C646, common_routine_return_compare_val);
+  		add_80_code(0x8001C646, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman
+   	((strcmp("SLPS_022.20;1", bootfile)) == 0) { // Japan
+		/*
+		D006C92A 1040
+		8006C92A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006C92A, common_routine_return_compare_val);
+  		add_80_code(0x8006C92A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 2: Dr. Wily no Nazo
+   	((strcmp("SLPS_022.55;1", bootfile)) == 0) { // Japan
+		/*
+		D006CA82 1040
+		8006CA82 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006CA82, common_routine_return_compare_val);
+  		add_80_code(0x8006CA82, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Rockman 3: Dr. Wily no Saigo!?
+   	((strcmp("SLPS_022.62;1", bootfile)) == 0) { // Japan
+		/*
+		D006CA1A 1040
+		8006CA1A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006CA1A, common_routine_return_compare_val);
+  		add_80_code(0x8006CA1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 4: Aratanaru Yabou!!
+   	((strcmp("SLPS_023.24;1", bootfile)) == 0) { // Japan
+	 	/*
+ 		D007009C 001E
+		8007009C 0000
+ 		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x8007009C, readtoc_compare_val);
+  		add_80_code(0x8007009C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 5: Blues no Wana!?
+   	((strcmp("SLPS_023.38;1", bootfile)) == 0) { // Japan
+		/*
+		D006FD84 001E
+		8006FD84 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x8006FD84, readtoc_compare_val);
+  		add_80_code(0x8006FD84, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 6
+   	((strcmp("SLPS_023.79;1", bootfile)) == 0) { // Japan
+		/*
+		D006DA7A 1040
+		8006DA7A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006DA7A, common_routine_return_compare_val);
+  		add_80_code(0x8006DA7A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman X5
+   	((strcmp("SLPM_866.66;1", bootfile)) == 0) { // Japan
+		/*
+		D0070ED0 001E
+		80070ED0 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x80070ED0, readtoc_compare_val);
+  		add_80_code(0x80070ED0, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman X6
+   	((strcmp("SLPM_869.59;1", bootfile)) == 0) { // Japan
+		/*
+		D006EC40 001E
+		8006EC40 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x8006EC40, readtoc_compare_val);
+  		add_80_code(0x8006EC40, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Street Fighter EX2 Plus
+   	((strcmp("SLPS_025.08;1", bootfile)) == 0) { // Japan
+		/*
+		D01BD48A 1040
+		801BD48A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_s.shtml
+		*/
+  		add_D0_code(0x801BD48A, common_routine_return_compare_val);
+  		add_80_code(0x801BD48A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_805.17;1", bootfile)) == 0) { // Japan Demo
+		/*
+		D01BD13E 1040
+		801BD13E 1000
+		my code via aprip gameshark code conversion
+		*/
+  		add_D0_code(0x801BD48A, common_routine_return_compare_val);
+  		add_80_code(0x801BD13E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Spyro: Year Of The Dragon
+// codes co-developed by MottZilla (mostly) and myself. Get rekt anti-tamper/apv1/apv2
+	((strcmp("SCUS_944.67;1", bootfile)) == 0) { // has 2 versions, rev 0 and rev 1
+		ver_check = (load_addr); // First different byte between revisions is well the first byte :)
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if(ver_check_val == 0xF4) { // Rev 0
+			add_D0_code(0x8007F08C, 0x0001);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0002);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0003);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0004);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0005);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0006);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0007);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0008);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x0009);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000A);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000B);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000C);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000D);
+			add_80_code(0x8007F08C, 0x0000);
+			add_D0_code(0x8007F08C, 0x000E);
+			add_80_code(0x8007F08C, 0x0000);
+			install_cheat_engine();
+		} else { // 0x08 = Rev 1
+			add_D0_code(0x8007F23C, 0x0001);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0002);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0003);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0004);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0005);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0006);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0007);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0008);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x0009);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000A);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000B);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000C);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000D);
+			add_80_code(0x8007F23C, 0x0000);
+			add_D0_code(0x8007F23C, 0x000E);
+			add_80_code(0x8007F23C, 0x0000);
+			install_cheat_engine();
+    	}
+	} else if
+
+// Strider 2
+   	((strcmp("SLUS_011.63;1", bootfile)) == 0) { // USA
+		/*
+		D01F6570 001E
+		801F6570 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x801F6570, readtoc_compare_val);
+  		add_80_code(0x801F6570, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tokimeki Memorial 2 (soo many god damn discs/versions/bootfiles)
+   	(
+	// main game (5 discs)
+	   ((strcmp("SLPM_863.55;1", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 1
+	|| ((strcmp("SLPM_863.50;1", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 1
+	|| ((strcmp("SLPM_863.56;1", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 2
+	|| ((strcmp("SLPM_863.51;1", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 2
+	|| ((strcmp("SLPM_863.57;1", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 3
+	|| ((strcmp("SLPM_863.52;1", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 3
+	|| ((strcmp("SLPM_863.58;1", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 4
+	|| ((strcmp("SLPM_863.53;1", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 4
+	|| ((strcmp("SLPM_863.59;1", bootfile)) == 0) // Tokimeki Memorial 2 Rev 0/Rev 1 Disc 5
+	|| ((strcmp("SLPM_863.54;1", bootfile)) == 0) // Tokimeki Memorial 2 Limited Box Disc 5
+	// dlc evs (3 discs)
+	|| ((strcmp("SLPM_805.27;1", bootfile)) == 0) // Tokimeki Memorial 2 Emotional Voice System Append Disc 1
+	|| ((strcmp("SLPM_805.44;1", bootfile)) == 0) // Tokimeki Memorial 2 Emotional Voice System Append Disc 2
+	|| ((strcmp("SLPM_805.50;1", bootfile)) == 0) // Tokimeki Memorial 2 Emotional Voice System Append Disc 3
+	) {
+		/*
+		D0011514 001E
+		80011514 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x80011514, readtoc_compare_val);
+  		add_80_code(0x80011514, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tomba! 2: The Evil Swine Return
+   	((strcmp("SCUS_944.54;1", bootfile)) == 0) { // USA
+		/*
+		D002542C 001E
+		8002542C 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x8002542C, readtoc_compare_val);
+  		add_80_code(0x8002542C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tron ni Kobun
+   	((strcmp("SLPS_021.08;1", bootfile)) == 0) {  // Japan
+		/*
+		D004E168 001E
+		8004E168 0000
+		my code via aprip
+		*/
+  		add_D0_code(0xD004E168, readtoc_compare_val);
+  		add_80_code(0x8004E168, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Vandal Harts II
+   	((strcmp("SLUS_009.40;1", bootfile)) == 0) { // USA
+ 		/*
+		D00865FC 001E
+		800865FC 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x800865FC, readtoc_compare_val);
+  		add_80_code(0x800865FC, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Wild Arms 2
+   	(
+	((strcmp("SCUS_944.84;1", bootfile)) == 0) // USA Disc 1
+	|| ((strcmp("SCUS_944.98;1", bootfile)) == 0) // USA Disc 2
+	) {
+   		/*
+   		D003A4E8 001E
+   		8003A4E8 0000
+ 		my code via aprip to patch out readtoc
+    	*/
+  		add_D0_code(0x8003A4E8, readtoc_compare_val);
+  		add_80_code(0x8003A4E8, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.92;1", bootfile)) == 0) { // USA Demo
+		/*
+   		D003A5D4 001E
+   		8003A5D4 0000
+		my code via aprip gameshark code conversion on my own code (code-ception)
+    	*/
+  		add_D0_code(0x8003A5D4, readtoc_compare_val);
+  		add_80_code(0x8003A5D4, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// World Soccer Jikkyou Winning Eleven 4
+   	((strcmp("SLPM_862.91;1", bootfile)) == 0) { // Japan Rev 0/Japan Rev 1
+		/*
+   		D01030CA 1040
+		801030CA 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_w.shtml
+    	*/
+  		add_D0_code(0x801030CA, common_routine_return_compare_val);
+  		add_80_code(0x801030CA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// XI[SAI] Jumbo
+   	((strcmp("SCPS_101.23;1", bootfile)) == 0) { // Japan
+	   	/*
+   		D010178A 1040
+		8010178A 1000
+		code 1 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x8010178A, common_routine_return_compare_val);
+  		add_80_code(0x8010178A, common_routine_return_patch_val);
+ 		/*
+		D00A370A 1040
+		800A370A 1000
+		code 2 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x800A370A, common_routine_return_compare_val);
+  		add_80_code(0x800A370A, common_routine_return_patch_val);
+ 		/*
+		D0113C1A 1040
+		80113C1A 1000
+		code 3 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x80113C1A, common_routine_return_compare_val);
+  		add_80_code(0x80113C1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Yu-Gi-Oh! Forbidden Memories
+   	(
+	((strcmp("SLPM_863.96;1", bootfile)) == 0) // Japan
+	|| ((strcmp("SLPM_863.98;1", bootfile)) == 0) // Japan Demo
+	|| ((strcmp("SLUS_014.11;1", bootfile)) == 0) // USA
+	|| ((strcmp("SLES_039.47;1", bootfile)) == 0) // Europe
+	|| ((strcmp("SLES_039.48;1", bootfile)) == 0) // France
+	|| ((strcmp("SLES_039.49;1", bootfile)) == 0) // Germany
+	|| ((strcmp("SLES_039.50;1", bootfile)) == 0) // Spain
+	|| ((strcmp("SLES_039.51;1", bootfile)) == 0) // Italy
+	) {
+		/*
+		D016818A 1040
+		8016818A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_y.shtml
+    	*/
+  		add_D0_code(0x8016818A, common_routine_return_compare_val);
+  		add_80_code(0x8016818A, common_routine_return_patch_val);
+		install_cheat_engine();
+    }
+}
\ No newline at end of file
diff --git a/loader/ap-bypass.h b/loader/ap-bypass.h
new file mode 100644
index 0000000..4c69172
--- /dev/null
+++ b/loader/ap-bypass.h
@@ -0,0 +1,9 @@
+
+#pragma once
+
+void activate_anti_anti_piracy(const char * bootfile, const int32_t load_addr);
+void add_8bit_code(const uint32_t gs1, const uint8_t gs2, const uint8_t gs_code_type);
+void add_16bit_code(const uint32_t gs1, const uint16_t gs2, const uint8_t gs_code_type);
+void install_cheat_engine();
+
+extern bool cheat_engine_installed;
diff --git a/tmp/og-tonyhax.0bp/loader/bios-asm.S b/loader/bios-asm.S
index 93837fa..a71573d 100644
--- a/tmp/og-tonyhax.0bp/loader/bios-asm.S
+++ b/loader/bios-asm.S
@@ -69,11 +69,6 @@ memcpy:
 	li t1, 0x2A
 	j 0xA0
 
-.global std_out_puts
-std_out_puts:
-	li t1, 0x3E
-	j 0xA0
-
 .global DoExecute
 DoExecute:
 	# Pepsiman (J) crashes if s5 is not zero
@@ -137,6 +132,11 @@ CdReadSector:
 	li t1, 0xA5
 	j 0xA0
 
+.global SetMemSize
+SetMemSize:
+	li t1, 0x9F
+	j 0xA0
+
 ###############
 # B-FUNCTIONS #
 ###############
diff --git a/tmp/og-tonyhax.0bp/loader/bios.c b/loader/bios.c
index 0f3d558..2ec6a3f 100644
--- a/tmp/og-tonyhax.0bp/loader/bios.c
+++ b/loader/bios.c
@@ -5,23 +5,13 @@
 #include "debugscreen.h"
 #include "str.h"
 
-void * original_disc_error;
-
-bool console_has_tty() {
-	/*
-	 * Check if the console has a SCN2681 TTY used for debug by writing data to the control
-	 * registers and reading it back.
-	 *
-	 * The control is 16 bit wide, and is accessed by writing or reading twice the same register.
-	 */
-	volatile uint8_t * scn2681modereg = (uint8_t *) 0x1F802020;
+// Set to zero unless you are using an emulator or have a physical UART on the PS1, else it'll freeze
+const uint32_t tty_enabled = 0;
 
-	*scn2681modereg = 0x55;
-	*scn2681modereg = 0xAA;
-	return *scn2681modereg == 0x55 && *scn2681modereg == 0xAA;
-}
+void * original_disc_error;
 
 void bios_reinitialize() {
+	// See https://github.com/ogamespec/psxdev/blob/master/reverse/Main.c for reference to some of this...
 	// Disable interrupts
 	EnterCriticalSection();
 
@@ -52,8 +42,11 @@ void bios_reinitialize() {
 	I_STAT = 0;
 	I_MASK = 0;
 
-	// Setup devices.
-	InstallDevices(console_has_tty());
+	// Setup devices
+	InstallDevices(tty_enabled);
+
+	// BIOS sets the memory to 8MB (somewhere, haven't seen exactly where but this is well known), which causes the RAM to be mirrored 4 times since there is actually only 2MBs of RAM. The thing is, some games set this to the 'correct' value of 2 for the appropriate 2MBs of RAM. This will cause issues when booting games, so we explicitly set it like the BIOS does which is what every game initially expects at boot.
+	SetMemSize(8); // fixes Ridge Racer USA GSHAX boot method getting stuck at the doexecute() call for discs such as the Tonyhax International ROM Flasher CD
 
 	/*
 	 * Configure with default values
@@ -92,7 +85,7 @@ void bios_reinitialize() {
 	// End of code adapted
 
 	// Re-enable interrupts
-	ExitCriticalSection();
+	ExitCriticalSection(); // unnecesary because SetConf() does this? Waiting on verdict from Socram8888: https://github.com/socram8888/tonyhax/issues/149
 
 	// Save for later
 	original_disc_error = BIOS_A0_TABLE[0xA1];
diff --git a/tmp/og-tonyhax.0bp/loader/bios.h b/loader/bios.h
index c5b26f3..9498989 100644
--- a/tmp/og-tonyhax.0bp/loader/bios.h
+++ b/loader/bios.h
@@ -219,13 +219,6 @@ void ExitCriticalSection();
  */
 uint32_t todigit(char c);
 
-/**
- * Prints a text through the TTY.
- *
- * @param text text to print
- */
-void std_out_puts(const char * text);
-
 /**
  * Starts a previously loaded executable.
  *
@@ -439,3 +432,10 @@ void InstallDevices(uint32_t enable_tty);
  * Table C, call 0x1C.
  */
 void AdjustA0Table(void);
+
+/**
+ * Called to set the RAM to 8MBs, which enables the mirroring of RAM 4 times in the real 2MBs of RAM (which is exactly what the BIOS ends up doing)
+ *
+ * Table A, call 0x9F.
+ */
+void SetMemSize(uint8_t mem_size);
\ No newline at end of file
diff --git a/tmp/og-tonyhax.0bp/loader/cdrom.c b/loader/cdrom.c
index dddc533..40d9b6f 100644
--- a/tmp/og-tonyhax.0bp/loader/cdrom.c
+++ b/loader/cdrom.c
@@ -43,6 +43,40 @@ void cd_command(uint_fast8_t cmd, const uint8_t * params, uint_fast8_t params_le
 	CD_REGS[1] = cmd;
 }
 
+void cd_command_race(uint_fast8_t cmd, const uint8_t * params, uint_fast8_t params_len) {
+
+	// Wait for previous command to finish, if any
+	//while (CD_REGS[0] & 0x80);
+
+	// Switch to page 0
+	cd_set_page(0);
+
+	// Clear read and write FIFOs
+	CD_REGS[3] = 0xC0;
+
+	// Copy request
+	while (params_len != 0) {
+		CD_REGS[2] = *params;
+		params++;
+		params_len--;
+	}
+
+	// Switch to page 1
+	cd_set_page(1);
+
+	// Disable interrupts as we'll poll
+	CD_REGS[2] = 0x00;
+
+	// Acknowledge interrupts, if there were any
+	CD_REGS[3] = 0x07;
+
+	// Switch to page 0
+	cd_set_page(0);
+
+	// Finally write command to start
+	CD_REGS[1] = cmd;
+}
+
 uint_fast8_t cd_wait_int(void) {
 
 	// Wait for command to finish, if any
@@ -64,6 +98,28 @@ uint_fast8_t cd_wait_int(void) {
 	return interrupt;
 }
 
+uint_fast8_t cd_wait_int_race(void) {
+
+	// Wait for command to finish, if any
+	//while (CD_REGS[0] & 0x80);
+
+	// Switch to page 1
+	cd_set_page(1);
+
+	// Wait until an interrupt happens (int != 0)
+	uint_fast8_t interrupt;
+	do {
+		interrupt = CD_REGS[3] & 0x07;
+	} while (interrupt == 0);
+
+	// Acknowledge it
+	CD_REGS[3] = 0x07;
+
+	// Return it
+	return interrupt;
+}
+
+
 uint_fast8_t cd_read_reply(uint8_t * reply_buffer) {
 
 	// Switch to page 1
@@ -81,6 +137,9 @@ uint_fast8_t cd_read_reply(uint8_t * reply_buffer) {
 	return len;
 }
 
+//we can't trust this due to a race condition. If the actual BIOS executes a CD command (affects the Tonyhax International ROM), or a game is in the middle of executing a CD command when Tonyhax International starts (affects GSHAX), and this is executed close enough in the Tonyhax International loader code itself, it will get stuck if done like below:
+
+/*
 bool cd_drive_init() {
 	cd_command(CD_CMD_INIT, NULL, 0);
 
@@ -96,18 +155,22 @@ bool cd_drive_init() {
 
 	return true;
 }
+*/
 
-bool cd_drive_reset() {
-	// Issue a reset
+void cd_drive_init() {
+	cd_command_race(CD_CMD_INIT, NULL, 0);
+
+	cd_wait_int_race();
+	cd_wait_int_race();
+}
+
+void cd_drive_reset() {
+	// Issue a reset (looses authentication and or unlock when completed, so do an unlock after this)
 	cd_command(CD_CMD_RESET, NULL, 0);
 
-	// Should succeed with 3
-	if (cd_wait_int() != 3) {
-		return false;
-	}
+	// Should succeed with 3 but doesn't sometimes so we can't check the return value
+	cd_wait_int();
 
 	// Need to wait for some cycles before it springs back to life
-	for (int i = 0; i < 0x400000; i++);
-
-	return true;
+	for (volatile int i = 0; i < 0x400000; i++); // unmodifiable compiler code when using -Os optimizations
 }
diff --git a/tmp/og-tonyhax.0bp/loader/cdrom.h b/loader/cdrom.h
index 438e7cd..c26874d 100644
--- a/tmp/og-tonyhax.0bp/loader/cdrom.h
+++ b/loader/cdrom.h
@@ -8,6 +8,12 @@
 #define CD_CMD_TEST 0x19
 #define CD_CMD_RESET 0x1C
 #define CD_TEST_REGION 0x22
+#define CD_CMD_SET_SESSION 0x12
+#define CD_CMD_STOP 0x08
+#define CD_CMD_GETID 0x1A
+#define CD_CMD_SETMODE 0x0E
+#define CD_CMD_GETTN 0x13
+#define CD_CMD_GETTD 0x14
 
 /**
  * Starts executing a CD command.
@@ -38,11 +44,9 @@ uint_fast8_t cd_read_reply(uint8_t * reply_buffer);
  *
  * @returns true if succeded, or false otherwise.
  */
-bool cd_drive_init(void);
+//bool cd_drive_init(void);
+// we can't trust that:
+void cd_drive_init();
 
-/**
- * Resets the drive.
- *
- * @returns true if succeded, or false otherwise.
- */
-bool cd_drive_reset(void);
+// Resets the drive.
+void cd_drive_reset();
diff --git a/tmp/og-tonyhax.0bp/loader/debugscreen.c b/loader/debugscreen.c
index cb8c32e..926cb0c 100644
--- a/tmp/og-tonyhax.0bp/loader/debugscreen.c
+++ b/loader/debugscreen.c
@@ -113,7 +113,7 @@ void debug_init() {
 	gpu_flush_cache();
 
 	// Draw border
-	debug_text_at(TH_MARGIN, 40, "tonyhax " STRINGIFY(TONYHAX_VERSION));
+	debug_text_at(TH_MARGIN, 40, "tonyhax international " STRINGIFY(TONYHAX_VERSION));
 	struct gpu_solid_rect band = {
 		.pos = {
 			.x = 0,
@@ -237,9 +237,12 @@ void debug_write(const char * str, ...) {
 	} else {
 		last_printed_count++;
 
-		// Same line, so print with a repeat counter
-		mini_sprintf(formatted_repeated, "%s (x%d)", last_printed_line, last_printed_count);
-
+		// Same line, so print with a repeat counter unless we are waiting for controller input on a Japanese console
+		if(!controller_input) {
+			mini_sprintf(formatted_repeated, "%s (x%d)", last_printed_line, last_printed_count);
+		} else {
+			mini_sprintf(formatted_repeated, "%s", last_printed_line);
+		}
 		to_print = formatted_repeated;
 	}
 
diff --git a/tmp/og-tonyhax.0bp/loader/debugscreen.h b/loader/debugscreen.h
index 6ae71a5..d06a360 100644
--- a/tmp/og-tonyhax.0bp/loader/debugscreen.h
+++ b/loader/debugscreen.h
@@ -10,3 +10,5 @@ void debug_write(const char * str, ...);
 void debug_text_at(uint_fast16_t x, uint_fast16_t y, const char * str);
 
 void debug_switch_standard(bool pal);
+
+extern bool controller_input;
\ No newline at end of file
diff --git a/tmp/og-tonyhax.0bp/loader/generate-tonyhax-mcs.sh b/loader/generate-tonyhax-mcs.sh
index 33116fa..b01a8b9 100644
--- a/tmp/og-tonyhax.0bp/loader/generate-tonyhax-mcs.sh
+++ b/loader/generate-tonyhax-mcs.sh
@@ -25,11 +25,11 @@ load_len=$(printf "%08X" $(stat -c %s $bin_file))
 
 # Create file
 cp "$tpl_file" "$mcs_file"
-echo -n "tonyhax ${version}" | dd status=none conv=notrunc bs=1 seek=132 of="$mcs_file"
+echo -n "tonyhax-i ${version}" | dd status=none conv=notrunc bs=1 seek=132 of="$mcs_file"
 dd status=none conv=notrunc bs=1 seek=384 if=$bin_file of="$mcs_file"
 
 # Insert address at 0xC0 and length at 0xC4, which is 0x40 and 0x44 inside the save file header
-echo -ne "\x${ro_start:6:2}\x${ro_start:4:2}\x${ro_start:2:2}\x${ro_start:0:2}\x${load_len:6:2}\x${load_len:4:2}\x${load_len:2:2}\x${load_len:0:2}" | dd status=none conv=notrunc of=tonyhax.mcs bs=1 seek=192
+echo -ne "\x${ro_start:6:2}\x${ro_start:4:2}\x${ro_start:2:2}\x${ro_start:0:2}\x${load_len:6:2}\x${load_len:4:2}\x${load_len:2:2}\x${load_len:0:2}" | dd status=none conv=notrunc of="$mcs_file" bs=1 seek=192
 
 # Cleanup
 rm $bin_file
diff --git a/tmp/og-tonyhax.0bp/loader/patch-ap.S b/tmp/og-tonyhax.0bp/loader/patch-ap.S
deleted file mode 100644
index 85511eb..0000000
--- a/tmp/og-tonyhax.0bp/loader/patch-ap.S
+++ /dev/null
@@ -1,196 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# Intercepts the syscall(1) (aka EnterCriticalSection).
-#
-# When this code is executed, the registers are as follows:
-#   - v0: saved thread registers, must NOT be modified.
-# The rest of the registers are not critical and can be used freely.
-#
-.globl patch_ap_start
-patch_ap_start:
-	# Load the SP value
-	lw t0, 0x7C(v0)
-
-	#
-	# If we are being called from an antimodchip module, the call stack will look like this:
-	#  - (game code)
-	#  - ap_check
-	#  - ap_failed
-	#  - StopCallback
-	#  - disable_ints
-	#  - EnterCriticalSection
-	#
-	# For all known modules, the return address from StopCallback to ap_failed sits at SP+0x28.
-	#
-	# Before reading from this address, we will check that after adding that offset, we do not
-	# cross a 2MB boundary, which could cause an illegal memory read.
-	#
-	# Without this check the following games crash:
-	#  - Elemental Gearbolt (U) (SLUS-00654), calling with a stack at 0x807FFFE0, as we attempt
-	#    to read from 0x80800008.
-	#  - Rival Schools (U) (SLUS-00681), calling with a stack of 0x801FFFD8, as we attempt to
-	#    read from 0x80200000. A mirror would be generally present here, but not for this game
-	#    as it calls SetMemSize(2) to intentionally block this.
-	#
-	# Some games, like Grind Session (U) (SCUS-94568) use the scratchpad during gameplay for the
-	# stack, which is only 1KB. For now, we will not add a safety check for this case since the
-	# vast majority of games store the stack in RAM and no game is known to crash without it.
-	#
-	addi t1, t0, 0x28
-	xor t1, t0
-	srl t1, 21
-	bne t1, zero, patch_ap_skip
-
-	# Load alledged return address
-	lw t1, 0x28(t0)
-
-	#
-	# Check now if the loaded value could be a word-aligned address in either the KUSEG
-	# (0x00000000-0x007FFFFF) or the KSEG0 (0x80000000-0x807FFFFF) regions, which is were user
-	# code is executed.
-	#
-	# Most games use the KSEG0, except for Emperors New Groove (U) (SCUS-94571) whose programmers
-	# seemed to prefer the KUSEG region.
-	#
-	# We cannot limit ourselves to checking the first 2MB of RAM, because some games, like
-	# Robbit Mon Dieu (J) (SCPS-10103) use a mirror (0x80600000-0x807FFFFF).
-	#
-	li t2, 0x7F800003
-	and t2, t1
-	bne t2, zero, patch_ap_skip
-
-	#
-	# First, we will attempt to handle a version 1 antimodchip module.
-	#
-	# This checks only for the presence of a dumb modchip, by checking if the SCEx counter
-	# increments when it should not. It is also only capable of displaying the stop screen
-	# in Japanese.
-	#
-	# The offsets for some of the checked games are:
-	#
-	# Um Jammer Lammy (PAL-E):
-	#  - ap_check           (0x801D8008)
-	#  - ap_failed          (0x801D83E0, called from 0x801D8174)
-	#  - StopCallback       (0x800356C4, called from 0x801D8400)
-	#  - disable_ints       (0x80035B54, called from 0x800356E0)
-	#  - EnterCriticalSection
-	#
-	# For Saru! Get You (NTSC-J):
-	#  - ap_check           (0x80136950)
-	#  - ap_failed          (0x80136D28, called from 0x80136ABC)
-	#  - StopCallback       (0x8002E814, called from 0x80136D48)
-	#  - disable_ints       (0x8002ECA4, called from 0x8002E82C)
-	#  - EnterCriticalSection
-	#
-	# The return call from StopCallback to ap_failed is located at SP+0x28. We will check if
-	# at this address +0x74 exists a "li v0, 0xE6000002", which is a black rentangle passed to
-	# the DrawPrim function to clear the screen.
-	#
-	# If it exists, we will patch the thread state to return back to ap_check, as if the
-	# ap_failed function had returned.
-	#
-
-	# Compare signature, and test for v2 if does not match
-	lw t2, 0x74(t1)
-	li t3, 0x3C02E600
-	bne t2, t3, patch_ap_v15
-
-	lw t2, 0x78(t1)
-	li t3, 0x34420002
-	bne t2, t3, patch_ap_v15
-
-	# Load return address from ap_failed to ap_check
-	lw t1, 0xE8(t0)
-
-	# Adjust stack pointer
-	addi t0, 0xF0
-
-	# Save and return
-	b patch_ap_save
-
-	#
-	# Handle another variant of the v1, used by Vandal Hearts II - Tenjou no Mon (J) (SLPM-86251)
-	#  - ap_check           (0x800C4868)
-	#  - ap_failed          (0x800C4C40, called from 0x800C49D4)
-	#  - StopCallback       (0x800D2700, called from 0x800C4C58)
-	#  - disable_ints       (0x800D2B90, called from 0x800D2718)
-	#  - EnterCriticalSection
-	#
-	# Same idea, except the load is now a "li v1, 0xE6000002" at +0x64 bytes after ap_failed
-	# returns to ap_check.
-	#
-	# The offsets are the same as for v2, so we will reuse those adjusts.
-	#
-patch_ap_v15:
-	lw t2, 0x64(t1)
-	li t3, 0x3C03E600
-	bne t2, t3, patch_ap_v2
-
-	lw t2, 0x68(t1)
-	li t3, 0x34630002
-	beq t2, t3, patch_ap_adjust_v2
-
-	#
-	# We will now attempt to patch an antimodchip v2 module.
-	#
-	# This one is smarter and checks that the SCEx wobble is present in the inner tracks,
-	# to detect CD swapping; and for dumb modchips by checking for absence of the wobble
-	# in the outer tracks.
-	#
-	# The offsets for some of the checked games are:
-	#
-	# Rockman 2 - Dr. Wily no Nazo (J) (SLPS-02255):
-	#  - ap_check           (0x8006CA58)
-	#  - ap_failed          (0x8006D654, called from 0x8006CE5C and 0x8006D238)
-	#  - StopCallback       (0x80024524, called from 0x8006D66C)
-	#  - disable_ints       (0x800249B4, called from 0x8002453C)
-	#  - EnterCriticalSection
-	#
-	# The return address from StopCallback to ap_failed is located at SP+0x28, exactly as above
-	# so we will not load it again.
-	#
-	# For this other version, we will check if at this return address +0x10 bytes exists a
-	# "sh zero, 0x1F801DAA", which is used to mute the audio.
-	#
-	# If that exists, we will patch the thread state to return back to ap_check.
-	#
-patch_ap_v2:
-	# Compare signature
-	lw t2, 0x18(t1)
-	li t3, 0x3C011F80
-	bne t2, t3, patch_ap_skip
-
-	lw t2, 0x1C(t1)
-	li t3, 0xA4201DAA
-	bne t2, t3, patch_ap_skip
-
-patch_ap_adjust_v2:
-	# Load return address to from ap_failed to ap_check
-	lw t1, 0x120(t0)
-
-	# Adjust stack pointer
-	addi t0, 0x128
-
-patch_ap_save:
-	# Zero the s0 and s1 stored in the thread state, so the state machine used by ap_check exits
-	sw zero, 0x48(v0)
-	sw zero, 0x4C(v0)
-
-	# Save adjusted stack pointer and return address
-	sw t0, 0x7C(v0)
-	sw t1, 0x88(v0)
-
-.globl patch_ap_success
-patch_ap_success:
-	j 0x12341234
-
-.globl patch_ap_skip
-patch_ap_skip:
-	j 0x12341234
-
-.globl patch_ap_end
-patch_ap_end:
diff --git a/tmp/og-tonyhax.0bp/loader/patch-fpb.S b/tmp/og-tonyhax.0bp/loader/patch-fpb.S
deleted file mode 100644
index e26fb72..0000000
--- a/tmp/og-tonyhax.0bp/loader/patch-fpb.S
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# The anti-FreePSXBoot patch.
-#
-# This patch is called right at the very end of the last step in the read sector finite state
-# machine:
-# https://github.com/grumpycoders/pcsx-redux/blob/f6484e8010a40a81e4019d9bfa1a9d408637b614/src/mips/openbios/sio0/card.c#L194
-#
-# When this code is executed, the registers are as follows:
-#   - v0 contains 1, or "success".
-#   - a1 contains the read buffer
-#   - a2 contains the current sector number
-#
-# If the sector being read is sector 0 and it contains "FPBZ" at +0x7C, we modify the read data
-# so it is detected as corrupted and the game skips reading from it
-#
-# The offsets have been checked against BIOSes 2.2, 3.0, 4.1 and 4.4
-#
-.globl patch_fpb_start
-patch_fpb_start:
-	lw t0, 0x7C(a1)
-	li t1, 0x5A425046
-	bne a2, 0, patch_fpb_ret
-	bne t0, t1, patch_fpb_ret
-
-	sw zero, 0(a1)
-patch_fpb_ret:
-	j 0x5B54
-
-.globl patch_fpb_end
-patch_fpb_end:
diff --git a/tmp/og-tonyhax.0bp/loader/patch-uart.S b/tmp/og-tonyhax.0bp/loader/patch-uart.S
deleted file mode 100644
index da95257..0000000
--- a/tmp/og-tonyhax.0bp/loader/patch-uart.S
+++ /dev/null
@@ -1,121 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# This is a complete replacement for the original std_out_putc the BIOS has.
-#
-# In this function:
-#  - a0: data to bitbang
-#  - t0: working registers
-#  - t1: bits to send
-#  - t2: last IRQ flag value
-#  - t3: 0x1F800000 (I/O start address)
-#  - t4: COP0 SR value
-#
-.globl patch_uartputc_start
-patch_uartputc_start:
-	# Add start (0) and stop (1) bits to byte
-	andi a0, 0xFF
-	sll a0, 1
-	ori a0, 0x200
-
-	# Newline (after processing)
-	li t0, (0x0A << 1 | 0x200)
-
-	# Bits to send (1 start + 8 data + 1 stop)
-	li t1, 10
-
-	# Compare against newline (0x0A)
-	bne a0, t0, notnl
-
-	# If newline, prepend a 0x0D, like the original function did and increment bit count
-	sll a0, 10
-	ori a0, (0x0D << 1 | 0x200)
-	addi t1, 10
-
-notnl:
-	# We will directly manipulate the COP0 status registers instead of using EnterCriticalSection
-	# to avoid other threads/interrupts from fucking up the timing.
-	#
-	# The reason is two-fold:
-	#  - The kernel does not support reentrant calls - if something calls us while we are
-	#    executing kernel code and we generate a syscall, we'd nuke the current thread state.
-	#
-	#  - SetConf calls printf while re-configuring the TCBs (thread control blocks). Executing
-	#    *any* interrupt at that point (which includes syscalls) will cause the interrupt
-	#    handler to write the current thread state to the zero address, wiping the interrupt
-	#    trampoline at 0x80.
-	#
-	# By directly manipulating this register we're opening ourselves to all kinds of race
-	# conditions, but since this is just for debugging tonyhax, that's good enough for me.
-
-	# Load current SR state in t4
-	mfc0 t4, $12
-
-	# Clear bits 10 and 0, the same flags WarmBoot clears
-	li t0, 0xFFFFFBFE
-	and t0, t4
-	mtc0 t0, $12
-
-	# Load I/O start
-	lui t3, 0x1F80
-
-	# Set timer 0 target to 293 cycles (33868800Hz/115200bps-1)
-	li t0, 293
-	sw t0, 0x1108(t3)
-
-	# Start timer 0 in:
-	# - Source clock to SysClk (33868800Hz)
-	# - Free-running mode
-	# - Reset on reaching target value
-	# - IRQ on repeat mode (can be fired multiple times)
-	# - Toggle IRQ flag (bit 10) on every IRQ
-	#
-	# We must not use the "reached target value" flag because that seems to be affected by some
-	# kind of undocumented hardware errata. In real hardware, that flag can read zero if the
-	# elapsed cycles between timer start and read and target values are both even or odd.
-	#
-	# Also note that although we are using the IRQ bits, interrupts are actually disabled so
-	# we will busy poll the corresponding bits.
-	li t0, 0x04D8
-	sw t0, 0x1104(t3)
-
-	# Current timer IRQ flag status
-	li t2, 0x0400
-
-writebit:
-	# Emit bit via /JOY pin of port 2.
-	# We need to invert it, then put it into JOY_CTRL.13.
-	# The XOR also sets the bit JOY_CTRL.2 which enables outputing the /JOY signal
-	andi t0, a0, 1
-	sll t0, 13
-	xori t0, 0x2002
-	sh t0, 0x104A(t3)
-
-	# Shift right current buffer
-	srl a0, 1
-
-	# Decrement count while we're waiting
-	addi t1, -1
-
-	# Wait until the interrupt flag toggles
-writewait:
-	lw t0, 0x1104(t3)
-	andi t0, 0x0400
-	beq t0, t2, writewait
-
-	# Save current IRQ flag status
-	move t2, t0
-
-	# If not done, keep going
-	bne t1, zero, writebit
-
-	# Restore coprocessor flags
-	mtc0 t4, $12
-
-	jr ra
-
-.global patch_uartputc_end
-patch_uartputc_end:
diff --git a/tmp/og-tonyhax.0bp/loader/patch-vandal-hearths-2.S b/tmp/og-tonyhax.0bp/loader/patch-vandal-hearths-2.S
deleted file mode 100644
index 67f389a..0000000
--- a/tmp/og-tonyhax.0bp/loader/patch-vandal-hearths-2.S
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# This game needs a special treatment, as it has the regular antipiracy, but also an extra check
-# by calling CdGetDiskType. If it detects the disc is a burned one, it aborts.
-#
-# Furthermore, if the BIOS is an European one, it gets stuck on a loop, calling the AP module
-# forever.
-#
-# So we will just nuke the antipiracy call. This function is supposed to return a nonzero, but
-# we do not need to patch v0 as there is a load constant into v0 right before the call.
-#
-.globl patch_vandal_start
-patch_vandal_start:
-	# Load address where the call to antipiracy sits
-	la t0, 0x80040C98
-
-	# Check if it matches "jal 0x80042854"
-	lw t1, 0(t0)
-	li t2, 0x0C010A15
-	bne t1, t2, patch_vandal_return
-
-	# If it does, NOP the opcode
-	sw zero, 0(t0)
-
-.globl patch_vandal_return
-patch_vandal_return:
-	# This will be replaced with the real address
-	j 0x12341234
-
-.globl patch_vandal_end
-patch_vandal_end:
diff --git a/tmp/og-tonyhax.0bp/loader/patcher.c b/tmp/og-tonyhax.0bp/loader/patcher.c
deleted file mode 100644
index 27c1c49..0000000
--- a/tmp/og-tonyhax.0bp/loader/patcher.c
+++ /dev/null
@@ -1,147 +0,0 @@
-
-#include "bios.h"
-#include "debugscreen.h"
-#include "str.h"
-#include "patcher.h"
-
-inline void encode_j(void * jump_location, const void * jump_dest) {
-	uint32_t * words = (uint32_t *) jump_location;
-	words[0] = 0x08000000 | (((uint32_t) jump_dest >> 2) & 0x3FFFFFF);
-}
-
-inline void encode_jal(void * jump_location, const void * jump_dest) {
-	uint32_t * words = (uint32_t *) jump_location;
-	words[0] = 0x0C000000 | (((uint32_t) jump_dest >> 2) & 0x3FFFFFF);
-}
-
-inline void encode_li(void * load_location, int regnum, uint32_t value) {
-	uint32_t * words = (uint32_t *) load_location;
-
-	// LUI - Load Upper Immediate
-	words[0] = 0x3C000000 | (regnum << 16) | (value >> 16);
-
-	// ORI - OR Immediate
-	words[1] = 0x34000000 | (regnum << 21) | (regnum << 16) | (value & 0xFFFF);
-}
-
-uint8_t * install_generic_antipiracy_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_ap_start;
-	extern uint8_t patch_ap_end;
-	extern uint8_t patch_ap_skip;
-	extern uint8_t patch_ap_success;
-
-	debug_write(" * Generic antipiracy");
-
-	// Get the handler info structure
-	handler_info_t * syscall_handler = bios_get_syscall_handler();
-
-	// Get the start of the verifier function (the only one set)
-	uint32_t * verifier = (uint32_t *) syscall_handler->verifier;
-
-	/*
-	 * At opcode 20 it accesses an 4-word array which contain where to jump depending on the
-	 * syscall performed. We're interested in modifying the value for 1 (EnterCriticalSection)
-	 * so we can intercept it and defuse the antimodchip.
-	 */
-	uint32_t lw_op = verifier[20];
-	if ((lw_op >> 16) != 0x8C39) {
-		debug_write("Aborted! Please report this!");
-		return install_addr;
-	}
-
-	// Extract location of cases array
-	void ** cases_array = (void **) (lw_op & 0xFFFF);
-
-	// Copy blob
-	memcpy(install_addr, &patch_ap_start, &patch_ap_end - &patch_ap_start);
-
-	/*
-	 * Insert the jump to the original code, which we'll use if the call was not originated from
-	 * an antipiracy module.
-	 */
-	encode_j(install_addr + (&patch_ap_skip - &patch_ap_start), cases_array[1]);
-
-	/*
-	 * Insert the jump we'll use to exit the exception handler once we have finished patching up
-	 * the thread state if the call was indeed originated from an antipiracy module.
-	 *
-	 * We'll use the address of syscall(0) which behaves as a nop to exit the exception.
-	 */
-	encode_j(install_addr + (&patch_ap_success - &patch_ap_start), cases_array[0]);
-
-	// Finally replace
-	cases_array[1] = install_addr;
-
-	return install_addr + (&patch_ap_end - &patch_ap_start);
-}
-
-uint8_t * install_vandal_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_vandal_start;
-	extern uint8_t patch_vandal_return;
-	extern uint8_t patch_vandal_end;
-
-	debug_write(" * Vandal Hearths 2 AP");
-
-	// Copy blob
-	memcpy(install_addr, &patch_vandal_start, &patch_vandal_end - &patch_vandal_start);
-
-	// Hook into call 16 of table B (OutdatedPadGetButtons), which is called once per frame
-	void ** b0_tbl = GetB0Table();
-
-	// Insert call to real function
-	encode_j(install_addr + (&patch_vandal_return - &patch_vandal_start), b0_tbl[0x16]);
-
-	// Replace it now
-	b0_tbl[0x16] = install_addr;
-
-	// Advance installation address
-	return install_addr + (&patch_vandal_end - &patch_vandal_start);
-}
-
-uint8_t * install_fpb_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_fpb_start;
-	extern uint8_t patch_fpb_end;
-
-	debug_write(" * FreePSXBoot");
-
-	// Copy blob
-	memcpy(install_addr, &patch_fpb_start, &patch_fpb_end - &patch_fpb_start);
-
-	// Install it
-	encode_jal((void *) 0x5B40, install_addr);
-
-	// Advance installation address
-	return install_addr + (&patch_fpb_end - &patch_fpb_start);
-}
-
-void patcher_apply(const char * boot_file) {
-	// We have plenty of space at the end of table B
-	uint8_t * install_addr = (uint8_t *) (GetB0Table() + 0x5E);
-
-	// Install patches
-	debug_write("Installing patches:");
-
-	// Install a suitable antimodchip patch
-	if (strcmp(boot_file, "cdrom:\\SLUS_009.40;1") == 0) {
-		install_addr = install_vandal_patch(install_addr);
-	} else {
-		install_addr = install_generic_antipiracy_patch(install_addr);
-	}
-
-	// FreePSXBoot does not work on PS2 so skip its installation
-	if (bios_is_ps1()) {
-		install_addr = install_fpb_patch(install_addr);
-	}
-}
-
-void patcher_apply_softuart() {
-	// Exports defined by the patch
-	extern uint8_t patch_uartputc_start;
-	extern uint8_t patch_uartputc_end;
-
-	// Overwrite BIOS' std_out_putchar function
-	memcpy(BIOS_A0_TABLE[0x3C], &patch_uartputc_start, &patch_uartputc_end - &patch_uartputc_start);
-}
diff --git a/tmp/og-tonyhax.0bp/loader/patcher.h b/tmp/og-tonyhax.0bp/loader/patcher.h
deleted file mode 100644
index 5b24f53..0000000
--- a/tmp/og-tonyhax.0bp/loader/patcher.h
+++ /dev/null
@@ -1,12 +0,0 @@
-
-#pragma once
-
-/**
- * Install and apply suitable BIOS patches.
- */
-void patcher_apply(const char * boot_file);
-
-/**
- * Installs the softUART patch.
- */
-void patcher_apply_softuart();
diff --git a/loader/secondary-ff9.ld b/loader/secondary-ff9.ld
new file mode 100644
index 0000000..bd6af40
--- /dev/null
+++ b/loader/secondary-ff9.ld
@@ -0,0 +1,36 @@
+MEMORY {
+	ram(wrx)	:ORIGIN = 0x801F4380, LENGTH = 0x7E00
+}
+SECTIONS {
+	. = 0x801F4380;
+	PROVIDE(__RO_START__ = .);
+	.text :
+	{
+		*(.start)
+		*(.text .text.*)
+	} >ram
+	.rodata :
+	{
+		*(.rodata .rodata.*)
+	} >ram
+	.data :
+	{
+		*(.data .data.*)
+	} >ram
+	PROVIDE(__CRC_START__ = .);
+	.crc :
+	{
+		*(.crc .crc.*)
+	} >ram
+	PROVIDE(__BSS_START__ = .);
+	.bss :
+	{
+		*(.bss .bss.*)
+	} >ram
+	PROVIDE(__BSS_END__ = .);
+	/DISCARD/ :
+	{
+		*(*)
+	}
+}
+ENTRY (start)
diff --git a/tmp/og-tonyhax.0bp/loader/secondary.c b/loader/secondary.c
index 18a2cab..7f3e63f 100644
--- a/tmp/og-tonyhax.0bp/loader/secondary.c
+++ b/loader/secondary.c
@@ -10,13 +10,241 @@
 #include "crc.h"
 #include "debugscreen.h"
 #include "gpu.h"
-#include "patcher.h"
+#include "ap-bypass.h"
 #include "integrity.h"
 #include "io.h"
 
+//to test ROM functionality in emulation via boot CD, uncomment the following 2 lines:
+//#undef ROM
+//#define ROM
+
+//to test XSTATION ROM functionality in emulation via boot CD, uncomment the following 4 lines:
+//#undef XSTATION
+//#define XSTATION
+//#undef ROM
+//#define ROM
+
+//to test behavior without any APv2 bypasses enabled (useful for testing D0 AP bypass codes via save game file gameshark functionality rather then internal activate_anti_piracy() function), uncomment:
+//#define AP_BYPASS_DISABLE
+
+uint8_t sscmd;
+uint8_t cdcontrollerver[4];
+
+const char * p5_localized;
+const char * region_name;
+
+bool calibrate_laser = 0; // Only Japanese VC2 and VC3 consoles need this so it is off by default
+bool bugged_setsession = 0; // VC0 A, VC0 B, and VC1 A CDROM Controller BIOS versions all have a buggy SetSession command that requires a special work around to use
+bool enable_unlock = 1; // Disabled on VC0A and VC0B Japanese CDROM Controller BIOS versions automatically. On VC1A+ the testregion command is run and if the region is Japan it is also disabled.
+bool controller_input = 0; // When enabled, debug_write does not display the repeat messages counter. This is so we can draw a blank line and then wait for controller input using vsync in debug_write.
+bool first_rev = 0; // VC0 A and VC0 B do not need any anti-piracy patching as they are immune to additional copy protection routines because of the lack of the ReadTOC command in the CDROM Controller BIOS Firmware.
+bool installed_cheat_engine = 0; // The cheat engine is installed when parse_memcard_save_gameshark_codes() completes. Some games may go on to set explicit anti-piracy bypass GameShark codes however, so to prevent the cheat engine from being installed twice (which is wasteful) we set a flag here.
+bool did_read_mc = 0; // We need to set the GameShark codes AFTER the last bios_reintialize(). I want to call bios_reinitilize() after reading the memory card data to prevent anything screwy in booting games, so we can just parse the data later after the final bios_reinitialize since it's still in RAM.
+uint8_t number_of_gameshark_code_lines; // part of my basic format to store codes, this tells us how many we will activate
+uint8_t * user_start = (uint8_t *) 0x80010000;
+uint16_t mc_base = 0x102; // start of gs code data in memory card buffer
+
 // Loading address of tonyhax, provided by the secondary.ld linker script
 extern uint8_t __RO_START__, __BSS_START__, __BSS_END__;
 
+// for controller input functions
+void * address;		// For Calculating BIOS Functions
+uint8_t j;			// Joypad
+uint8_t padbuf[2][0x22];	// Joypad Buffers
+
+#if !defined TOCPERFECT
+#if defined ROM
+void run_shell() {
+	// runs Sony BIOS. Can access CD Player/Memory Card Manager. Can not boot any discs, even ones that normally work without the flash cart inserted in the console. This has been adapted code from the SCPH-1001 decomp: https://github.com/ogamespec/psxdev/blob/97fbb2d03e5aff4449097afd2b59690002cb2341/reverse/Main.c#L395
+
+	debug_write("Starting Sony BIOS...");
+	memcpy((void*)0x80030000, (void*)0xBFC18000, 0x67FF0); // uses 0x80030000-0x80077FF0
+	FlushCache();
+	((void (*)(void))0x80030000)();
+}
+#endif
+
+void controller_input_start() {
+	controller_input = 1; // disable the repeat counter used in debug_write until controller input is done, see debugscreen.c
+	// BIOS Function InitPAD(buf1,sz1,buf2,sz2)
+	address = (uint32_t *) GetB0Table()[0x12];
+	((void (*)(uint8_t*,uint32_t,uint8_t*,uint32_t)) address)(padbuf[0],0x22,padbuf[1],0x22); // BIOS InitPAD(buf1,sz1,buf2,sz2) exec
+	// BIOS Function StartPAD()
+	address = (void *) (GetB0Table()[0x13]);
+	((void (*)(void)) address)();	// BIOS StartPad exec
+}
+
+void controller_input_stop() { // this doubles as 'closing' the memory card functions
+	controller_input = 0; // Set debug_write back to normal (enable repeat counter) as controller input is done
+	// BIOS Function StopPAD()
+	address = (void *) (GetB0Table()[0x14]);
+	// StopPAD() as we are done using Joypad input
+	((void (*)(void)) address)();	// BIOS StopPad exec
+}
+
+void read_memcard() {
+/*
+InitCARD
+Initialize Memory Card BIOS.
+Library Header File Introduced Documentation Date
+libcard.lib libapi.h 3.0 12/14/98
+Syntax
+void InitCARD(
+long val) Specify sharing with controller
+Explanation
+Initializes the Memory Card BIOS and enters an idle state. val specifies whether or not there is sharing with
+the controller. (0: not shared; 1: shared.)
+When the BIOS is subsequently put into operation by StartCARD(), the low-level interface functions that
+begin with “ _card” can be used directly.
+The Memory Card file system uses these interfaces internally, so InitCARD() needs to be executed before
+_bu_init().
+There is no effect on the controller.
+*/
+	debug_write("Reading MC...");
+	int32_t read;
+	// BIOS Function InitCard(pad_enable)
+	int32_t pad_enable = 1; 
+	address = (uint32_t *) GetB0Table()[0x4A];
+	((void (*)(int32_t*)) address)(&pad_enable);
+	// BIOS Function StartCard()
+	address = (void *) (GetB0Table()[0x4B]);
+	((void (*)(void)) address)();
+	// BIOS Function _bu_init()
+	address = (void *) (GetB0Table()[0x55]);
+	((void (*)(void)) address)();
+	int32_t mc_fd = FileOpen("bu00:TONYHAXINTGS", FILE_READ);
+	if(mc_fd == -1) {
+		debug_write("Can not read MC, read error %d", GetLastError());
+		debug_write("Please try reinserting the memory card");
+	}
+
+	if (mc_fd > 0) {
+		read = FileRead(mc_fd, user_start, 0x2000); // read the entire file "TONYHAXINTGS" to the start of 'user RAM' (which will be cleared later before booting an executable). So 0x80010000-0x80012000 in RAM contains the contents of "TONYHAXINTGS". 
+		
+		if (read == -1) {
+			debug_write("Read error %d", GetLastError());
+			return;
+		}
+
+		FileClose(mc_fd);
+		number_of_gameshark_code_lines = user_start[mc_base + 1];
+		debug_write("%d code lines detected", number_of_gameshark_code_lines);
+
+		uint8_t sum;
+		uint8_t prev = 0;
+		uint8_t next;
+		uint8_t checksum_in_save_file = user_start[mc_base];
+
+		for (int i = 0x103; i < 0x2000; i++)
+		{
+			//debug_write("%x: @ %x", &user_start[i], user_start[i]);
+			next = user_start[i];
+			sum = prev + next;
+			sum &= 0xFF;
+			prev = sum;
+		}
+
+		if(checksum_in_save_file == sum) {
+			debug_write("Checksum: %x Verified", sum);
+			did_read_mc = 1; // set flag to parse codes uploaded to RAM, right before clearing RAM itself and booting the game
+		} else {
+			debug_write("Checksum: %x did not match the expected checksum %x!", sum, checksum_in_save_file);
+			debug_write("Can not enable codes, check that the TONYHAXINTGS file is not corrupted");
+		}
+	}
+}
+
+void parse_memcard_save_gameshark_codes() {
+	/*
+	TONYHAXINTGS format:
+
+	0x00-0x101 = static save file data
+
+	0x102 = checksum generated by thigsgen
+
+	0x103 = number of code lines in hex
+
+	0x104-0x107 = gameshark code address (may or may not include code prefix i.e. D0, E0, 30, or 80 could be 0x104)
+
+	0x108-0x109 = gameshark code mod value
+		
+	0x110-0x103 = 2nd gameshark code address
+
+	0x114-0x115 = 2nd gameshark code mod value (and then so on and so on for number of code lines in hex number)
+	*/
+
+	uint32_t gameshark_code_address;
+	uint8_t gs_code_type;
+
+	/*
+	uint32_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	for (int i = 0; i < 0x2000; i++)
+	{
+		debug_write("%x: @ %x", &user_start[i], user_start[i]);
+		next = user_start[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Memory card buffer checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	*/
+
+	for(int i = 0; i < number_of_gameshark_code_lines; i++) {
+		
+		gs_code_type = user_start[mc_base + 5];
+			
+		if(
+			(gs_code_type == 0xD0) || 
+			(gs_code_type == 0xD1) || 
+			(gs_code_type == 0xD2) || 
+			(gs_code_type == 0xD3) || 
+			(gs_code_type == 0xE0) || 
+			(gs_code_type == 0xE1) ||
+			(gs_code_type == 0xE2) || 
+			(gs_code_type == 0xE3) || 
+			(gs_code_type == 0x30)
+		) {
+			user_start[mc_base + 5] = 0x80; // we need to convert the prefix to the real address first byte of 0x80 for the cheat engine
+		}
+
+		gameshark_code_address = user_start[mc_base + 2] + (user_start[mc_base + 3] << 8) + (user_start[mc_base + 4] << 16) + (user_start[mc_base + 5] << 24);
+		//debug_write("GS Code Addr: %x", gameshark_code_address);
+
+
+		if(
+			(gs_code_type == 0x80) || 
+			(gs_code_type == 0xD0) || 
+			(gs_code_type == 0xD1) || 
+			(gs_code_type == 0xD2) || 
+			(gs_code_type == 0xD3)
+
+		) {
+			uint16_t gameshark_code_mod_val = user_start[mc_base + 6] + (user_start[mc_base + 7] << 8);
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_16bit_code(gameshark_code_address, gameshark_code_mod_val, gs_code_type);
+		}
+
+		if(
+			(gs_code_type == 0x30) || 
+			(gs_code_type == 0xE0) || 
+			(gs_code_type == 0xE1) || 
+			(gs_code_type == 0xE2) || 
+			(gs_code_type == 0xE3) 
+
+		) {
+			uint8_t gameshark_code_mod_val = user_start[mc_base + 6];
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_8bit_code(gameshark_code_address, gameshark_code_mod_val, gs_code_type);
+		}
+			
+		mc_base = (mc_base + 6); // advance 6 bytes from current val
+	}
+}
+#endif // TOCPERFECT
+
 void log_bios_version() {
 	/*
 	 * "System ROM Version 4.5 05/25/00 A"
@@ -31,7 +259,7 @@ void log_bios_version() {
 	}
 
 	debug_write("Console: %s", bios_is_ps1() ? "PS1": "PS2");
-	debug_write("BIOS: v%s", version);
+	debug_write("System BIOS: %s", version);
 }
 
 bool backdoor_cmd(uint_fast8_t cmd, const char * string) {
@@ -65,43 +293,6 @@ bool backdoor_cmd(uint_fast8_t cmd, const char * string) {
 }
 
 bool unlock_drive() {
-	uint8_t cd_reply[16];
-
-	// Run "GetRegion" test
-	uint8_t test = CD_TEST_REGION;
-	cd_command(CD_CMD_TEST, &test, 1);
-
-	// Should succeed with 3
-	if (cd_wait_int() != 3) {
-		debug_write("Region read failed");
-		return false;
-	}
-
-	// Read actual region text and null terminate it
-	int len = cd_read_reply(cd_reply);
-	cd_reply[len] = 0;
-
-	// Compare which is the fifth string we have to send to the backdoor
-	const char * region_name;
-	const char * p5_localized;
-	if (strcmp((char *) cd_reply, "for Europe") == 0) {
-		region_name = "European";
-		p5_localized = "(Europe)";
-	} else if (strcmp((char *) cd_reply, "for U/C") == 0) {
-		region_name = "American";
-		p5_localized = "of America";
-	} else if (strcmp((char *) cd_reply, "for NETEU") == 0) {
-		region_name = "NetYaroze (EU)";
-		p5_localized = "World wide";
-	} else if (strcmp((char *) cd_reply, "for NETNA") == 0) {
-		region_name = "NetYaroze (US)";
-		p5_localized = "World wide";
-	} else {
-		// +4 to skip past "for "
-		debug_write("Unsupported region: %s", (char *) (cd_reply + 4));
-		return false;
-	}
-
 	debug_write("Drive region: %s", region_name);
 
 	// Note the kernel's implementation of strlen returns 0 for nulls.
@@ -121,11 +312,31 @@ bool unlock_drive() {
 	return true;
 }
 
+#if !defined TOCPERFECT
 void wait_lid_status(bool open) {
 	uint8_t cd_reply[16];
+	
+	controller_input_start();
 
 	uint8_t expected = open ? 0x10 : 0x00;
 	do {
+
+		j = padbuf[0][3] ^ 0xFF;
+		debug_write(" "); // Vblank wait for controller input
+
+#if defined ROM // this is more optimized for variable button presses then otherwise if we didn't test both statements in an else if
+		if(j == 0x40) { // X button
+			controller_input_stop();
+			run_shell(); // launch Sony BIOS
+		} else if(j == 0x20) { // Circle button
+			read_memcard();
+		}
+#else // booting the shell is unnecessary for every other boot method besides the ROM so we don't include it
+		if(j == 0x20) { // Circle button
+			read_memcard();
+		}
+#endif // ROM
+
 		// Issue Getstat command
 		// We cannot issue the BIOS CD commands yet because we haven't called CdInit
 		cd_command(CD_CMD_GETSTAT, NULL, 0);
@@ -137,20 +348,158 @@ void wait_lid_status(bool open) {
 		cd_read_reply(cd_reply);
 
 	} while ((cd_reply[0] & 0x10) != expected);
+
+	controller_input_stop();
 }
 
-void try_boot_cd() {
-	int32_t read;
+bool is_lid_open() {
+	uint8_t cd_reply[16];
 
-	debug_write("Swap CD now");
-	wait_lid_status(true);
-	wait_lid_status(false);
+	// Issue Getstat command
+	// We cannot issue the BIOS CD commands yet because we haven't called CdInit
+	cd_command(CD_CMD_GETSTAT, NULL, 0);
 
+	// Always returns 3, no need to check
+	cd_wait_int();
+
+	// Always returns one, no need to check either
+	cd_read_reply(cd_reply);
+
+	if(cd_reply[0]==0x10) {
+		return true;
+	} else {
+		return false;
+	}   
+}
+
+bool licensed_drive() {
+	uint8_t getid_response[9];
+	unsigned char gid;
+
+	while(1) {
+    	cd_command(CD_CMD_GETID,0,0);
+		gid = cd_wait_int();
+		if(gid!=5)
+			break;
+	}
+	
+    cd_wait_int();
+	cd_read_reply(getid_response);
+
+	if(getid_response[0]==0x02 && getid_response[1]==0x00 && getid_response[2]==0x20 && getid_response[3]==0x00) {
+		return true;
+	} else {
+		return false;
+	}   
+}
+#endif // TOCPERFECT
+
+void re_cd_init() {
+	debug_write("Reinitializing kernel"); 
+	bios_reinitialize();
+	bios_inject_disc_error();
+	debug_write("Stopping Motor"); // Reset one last time to avoid potential lockups (here be dragons)
+	cd_command(CD_CMD_STOP, NULL, 0); cd_wait_int(); cd_wait_int();
+	
 	debug_write("Initializing CD");
 	if (!CdInit()) {
 		debug_write("Init failed");
 		return;
 	}
+}
+
+void try_boot_cd() {
+	int32_t read;
+#if defined FREEPSXBOOT
+	debug_write("Remove the FreePSXBoot memory card now from your console");
+#elif defined ROM
+	debug_write("With the CD drive open, press X to boot the Sony BIOS or");
+	debug_write("Press O to enable GS codes");
+#endif
+
+#if !defined XSTATION
+	uint8_t cbuf[4]; // CD Command Buffer
+
+#if !defined TOCPERFECT
+	if(enable_unlock) {
+		#if !defined ROM
+		debug_write("With the CD drive open, press O to enable GS codes");
+		#endif
+		debug_write("Put in a backup or import disc, then close the drive lid");
+		wait_lid_status(true); // doesn't wait during the ROM method, unsure why but it is what we want as it allows us to auto-boot with the ROM boot method
+		wait_lid_status(false);
+	} else {
+		if(is_lid_open() || !licensed_drive()) {	// If lid is open drive is not licensed, and if lid is closed we check if it is licensed (if it is not licensed but not open then the drive is closed and the user can open it and license it)
+			debug_write("Put in a real NTSC-J PSX game disc, then block the lid sensor");
+			wait_lid_status(true);
+			wait_lid_status(false); // Blocking lid sensor = 'closing lid'
+
+            debug_write("Initializing CD");	// Drive will be in licensed state after this is successful
+			if (!CdInit()) {
+				debug_write("Init failed");
+				debug_write("Try unblocking then blocking the lid sensor again");
+				return;
+			}
+		} // Drive is licensed and the lid is 'closed' at this point
+		debug_write("Drive is licensed");
+           
+		debug_write("Stopping motor");
+		cd_command(CD_CMD_STOP,0,0); cd_wait_int(); cd_wait_int();
+
+		debug_write("Press O to enable GS codes");
+		controller_input_start();
+
+		debug_write("Keep the lid sensor blocked until turning off the console");
+		debug_write("Remove the real NTSC-J PSX game disc");
+		debug_write("Put in a backup/import disc, then press X"); // Thanks MottZilla!
+            
+		while(1) { 
+			j = padbuf[0][3] ^ 0xFF;
+
+			if(j == 0x40) {
+				break; // X button boots disc
+			} else if(j == 0x20) { // Circle button enables codes
+				read_memcard(); // this allows Japanese console users to enable user supplied GameShark codes without having to unblock the lid sensor, resetting authentication which would just be more unnecessary steps.
+			}
+
+			debug_write(" "); // Vblank wait for controller input
+		}
+	    controller_input_stop();
+	}
+#endif // TOCPERFECT
+
+	if(!enable_unlock) {
+		if(bugged_setsession) {
+			debug_write("Sending SetSessionSuperUltraCommandSmash v2, please wait"); // always works on real hardware, DuckStation can get stuck here rarely though since it is not that accurate when it comes to emulating the early VC0A/VC0B/VC1A CDROM behavior
+			sscmd = 2; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int(); // There is a 3rd response we are ignoring by sending SetSession 1 next ASAP after SetSession 2.
+			sscmd = 1; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int();
+		} else {
+			debug_write("Sending SetSession 1");
+			sscmd = 1; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int();
+		}
+
+		if(calibrate_laser) { // VC2 and VC3s do auto Bias/Gain calibration when reading a newly inserted real NTSC-J PS1 disc. A swapped in CD-R or just a different disc in general needs this to be updated
+        	debug_write("Calibrating laser");
+        	cbuf[0] = 0x50; cbuf[1] = 0x38; cbuf[2] = 0x15; cbuf[3] = 0x0A;	// ModeCompensateTrackingAutoGain
+			cd_command(CD_CMD_TEST,&cbuf[0],4); 
+			cd_wait_int();
+		}
+	}
+#else // XSTATION DEFINED
+	debug_write("Open and then close the CD drive lid");
+	wait_lid_status(true); // doesn't wait during the ROM method, unsure why but it is what we want as it allows us to auto-boot with the ROM boot method
+	wait_lid_status(false);
+#endif // XSTATION
+
+	/*
+	We have to re-initilize the BIOS, stop, and init in that order to prevent the process from possibly freezing at this point on Japanese consoles. 
+	
+	The first reason this is required is because the SetSessionSuperUltraCommandSmash screws up interrupts since we are sending the 2nd SetSession command before the possible 3rd interrupt (which is a second INT5 response sent if session 2 does not actually exist). 
+		
+	The second reason is because of how we are using the BIOS controller functions, to go back to a clean state a bios re-intialization also accomplishes that.
+	*/
+
+	re_cd_init();
 
 	/*
 	 * Use the space the BIOS has allocated for reading CD sectors.
@@ -163,10 +512,17 @@ void try_boot_cd() {
 	uint8_t * data_buffer = (uint8_t *) (bios_is_ps1() ? 0xA000B070 : 0xA000A8D0);
 
 	debug_write("Checking game region");
-	if (CdReadSector(1, 4, data_buffer) != 1) {
+#if defined TOCPERFECT	
+    if (CdReadSector(1, 15, data_buffer) != 1) { // Real license data sector is copied to sector 15 by TOCPerfect Patch before it writes Japanese license data to sector 4 to allow booting via CD Player Swap Trick on early SCPH-3000 models
+		debug_write("Failed to read sector");
+		return;
+	}
+#else
+    if (CdReadSector(1, 4, data_buffer) != 1) {
 		debug_write("Failed to read sector");
 		return;
 	}
+#endif
 
 	const char * game_region;
 	bool game_is_pal = false;
@@ -203,9 +559,10 @@ void try_boot_cd() {
 	const char * bootfile = "cdrom:PSX.EXE;1";
 
 	char bootfilebuf[32];
-	debug_write("Loading SYSTEM.CNF");
 
+	debug_write("Loading SYSTEM.CNF");
 	int32_t cnf_fd = FileOpen("cdrom:SYSTEM.CNF;1", FILE_READ);
+    
 	if (cnf_fd > 0) {
 		read = FileRead(cnf_fd, data_buffer, 2048);
 		FileClose(cnf_fd);
@@ -221,18 +578,32 @@ void try_boot_cd() {
 		config_get_hex((char *) data_buffer, "TCB", &tcb);
 		config_get_hex((char *) data_buffer, "EVENT", &event);
 		config_get_hex((char *) data_buffer, "STACK", &stacktop);
-		if (config_get_string((char *) data_buffer, "BOOT", bootfilebuf)) {
+
+#if defined TOCPERFECT
+		if (config_get_string((char *) data_buffer, "BOOY", bootfilebuf)) {
 			bootfile = bootfilebuf;
+		} else {
+			uint32_t errorCode = GetLastError();
+			if (errorCode != FILEERR_NOT_FOUND) {
+				debug_write("Open error %d", errorCode);
+				return;
+			}
+
+			debug_write("Not found");
 		}
-
-	} else {
-		uint32_t errorCode = GetLastError();
-		if (errorCode != FILEERR_NOT_FOUND) {
-			debug_write("Open error %d", errorCode);
-			return;
+#else
+		if (config_get_string((char *) data_buffer, "BOOT", bootfilebuf)) {
+			bootfile = bootfilebuf;
+		} else {
+			uint32_t errorCode = GetLastError();
+			if (errorCode != FILEERR_NOT_FOUND) {
+				debug_write("Open error %d", errorCode);
+				return;
+			}
+
+			debug_write("Not found");
 		}
-
-		debug_write("Not found");
+#endif
 	}
 
 	// Use string format to reduce ROM usage
@@ -241,6 +612,8 @@ void try_boot_cd() {
 	debug_write(" * %s = %x", "STACK", stacktop);
 	debug_write(" * %s = %s", "BOOT", bootfile);
 
+	re_cd_init(); // Reset one last time to avoid potential lockups (here be dragons)
+
 	/*
 	 * SetConf is run by BIOS with interrupts disabled.
 	 *
@@ -248,13 +621,18 @@ void try_boot_cd() {
 	 * the interrupt handler will store the current thread state in the zero address, wiping
 	 * vital data, like the interrupt trampoline at 0x80.
 	 */
+	
 	debug_write("Configuring kernel");
 	EnterCriticalSection();
 	SetConf(event, tcb, stacktop);
-	ExitCriticalSection();
+	ExitCriticalSection(); // unnecessary because SetConf() does this? Waiting on verdict from Socram8888: https://github.com/socram8888/tonyhax/issues/149
+
+#if !defined TOCPERFECT
+	if(did_read_mc) // before clearing RAM (which contains our mem card buffer if applicable) but after last bios_reinitalize/setconf()
+		parse_memcard_save_gameshark_codes();
+#endif
 
 	debug_write("Clearing RAM");
-	uint8_t * user_start = (uint8_t *) 0x80010000;
 	bzero(user_start, &__RO_START__ - user_start);
 
 	debug_write("Reading executable header");
@@ -271,6 +649,37 @@ void try_boot_cd() {
 		return;
 	}
 
+	/*
+	uint32_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	uint8_t * ce = (uint8_t *) 0xC000;
+
+	for (int i = 0; i < 0x100; i++)
+	{
+		//debug_write("%x: @ %x", &ce[i], ce[i]);
+		next = ce[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Cheat engine checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	
+	uint8_t * codes = (uint8_t *) 0xD000;
+
+	for (int i = 0; i < 0x1FFB; i++)
+	{
+		//debug_write("%x: @ %x", &codes[i], codes[i]);
+		next = codes[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Cheat engine enabled codes Checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	*/
+
 	exe_header_t * exe_header = (exe_header_t *) (data_buffer + 0x10);
 
 	// If the file overlaps tonyhax, we will use the unstable LoadAndExecute function
@@ -286,6 +695,16 @@ void try_boot_cd() {
 		// Restore original error handler
 		bios_restore_disc_error();
 
+		#if !defined XSTATION
+		#if !defined AP_BYPASS_DISABLE
+		if(!first_rev)
+			activate_anti_anti_piracy(bootfile, (int32_t) exe_header->load_addr);
+		#endif
+		#endif
+
+		if((did_read_mc) && (!cheat_engine_installed))
+			install_cheat_engine();
+
 		LoadAndExecute(bootfile, exe_header->initial_sp_base, exe_header->initial_sp_offset);
 		return;
 	}
@@ -299,8 +718,6 @@ void try_boot_cd() {
 
 	FileClose(exe_fd);
 
-	patcher_apply(bootfile);
-
 	if (game_is_pal != gpu_is_pal()) {
 		debug_write("Switching video mode");
 		debug_switch_standard(game_is_pal);
@@ -311,6 +728,16 @@ void try_boot_cd() {
 	// Restore original error handler
 	bios_restore_disc_error();
 
+#if !defined XSTATION
+#if !defined AP_BYPASS_DISABLE
+	if(!first_rev)
+		activate_anti_anti_piracy(bootfile, (int32_t) exe_header->load_addr);
+#endif
+#endif
+
+	if((did_read_mc) && (!cheat_engine_installed))
+		install_cheat_engine();
+
 	// Games from WarmBoot start with interrupts disabled
 	EnterCriticalSection();
 
@@ -321,6 +748,7 @@ void try_boot_cd() {
 }
 
 void main() {
+	
 	// Undo all possible fuckeries during exploiting
 	bios_reinitialize();
 
@@ -337,24 +765,76 @@ void main() {
 
 	bios_inject_disc_error();
 	log_bios_version();
+    
+	debug_write("Resetting Drive");
+	cd_drive_init();
+
+	sscmd = 0x20; cd_command(CD_CMD_TEST,(unsigned char *)&sscmd,1); cd_wait_int(); 
+	cd_read_reply(cdcontrollerver);	// Test Command $19,$20 gets the CDROM BIOS
+	debug_write("CD BIOS: %x", *(uint32_t*) cdcontrollerver);
+   	if(cdcontrollerver[0] == 0x94) {    
+        bugged_setsession = 1;
+        enable_unlock = 0; // VC0 A and VC0 B are both from 1994 and don't support the getregion command to figure out if it is unlockable or not.
+        first_rev = 1;
+    } 
+    else if(cdcontrollerver[1] == 0x05 && cdcontrollerver[2] == 0x16 && cdcontrollerver[0] == 0x95 && cdcontrollerver[3] == 0xC1) {     
+        bugged_setsession = 1; // NOTE I don't think this will ever be triggered but just in case. Earliest SCPH-3000s and late SCPH-1000s are VC0B and later SCPH-3000s are VC1B. Only unlockable systems have VC1A it seems.
+    }
+    else if((cdcontrollerver[3] == 0xC2) || (cdcontrollerver[3] == 0xC3)) {   
+        calibrate_laser = 1;
+    }
+
+#if !defined XSTATION
+	if(enable_unlock) {
+		uint8_t cd_reply[16];
+		// Run "GetRegion" test
+		uint8_t test = CD_TEST_REGION;
+		cd_command(CD_CMD_TEST, &test, 1);
+
+		// Should succeed with 3
+		if (cd_wait_int() != 3) {
+			debug_write("Region read failed");
+			return;
+		}
 
-	debug_write("Resetting drive");
-	if (!cd_drive_init()) {
-		debug_write("Reset failed");
-		return;
-	}
+		// Read actual region text and null terminate it
+		int len = cd_read_reply(cd_reply);
+		cd_reply[len] = 0;
+
+		// Compare which is the fifth string we have to send to the backdoor
+		if (strcmp((char *) cd_reply, "for Europe") == 0) {
+			region_name = "European";
+			p5_localized = "(Europe)";
+		} else if (strcmp((char *) cd_reply, "for U/C") == 0) {
+			region_name = "American";
+			p5_localized = "of America";
+		} else if (strcmp((char *) cd_reply, "for NETEU") == 0) {
+			region_name = "NetYaroze (EU)";
+			p5_localized = "World wide";
+		} else if (strcmp((char *) cd_reply, "for NETNA") == 0) {
+			region_name = "NetYaroze (US)";
+			p5_localized = "World wide";
+		} else if (strcmp((char *) cd_reply, "for Japan") == 0) {
+			enable_unlock = 0;
+		} else {
+			// +4 to skip past "for "
+			debug_write("Unsupported region: %s", (char *) (cd_reply + 4));
+			return;
+		}
 
-	debug_write("Unlocking drive");
-	if (!unlock_drive()) {
-		return;
+		if(enable_unlock) { // Check again, this could be false now
+			#if defined TOCPERFECT // Get TOC via reset + unlock instead of unlock + opening/closing the drive lid for auto loading in TOCPerfect, thanks MottZilla!
+				debug_write("Resetting drive");
+				cd_drive_reset();
+			#endif
+			debug_write("Unlocking drive");
+			if (!unlock_drive())
+				return;
+		}
 	}
+#endif // XSTATION
 
 	while (1) {
-#if SOFTUART_PATCH
-		patcher_apply_softuart();
-		std_out_puts("SoftUART ready\n");
-#endif
-
 		try_boot_cd();
 
 		debug_write("Reinitializing kernel");
diff --git a/tmp/og-tonyhax.0bp/loader/secondary.ld b/loader/secondary.ld
index 7dc880a..dfd4eaa 100644
--- a/tmp/og-tonyhax.0bp/loader/secondary.ld
+++ b/loader/secondary.ld
@@ -1,8 +1,8 @@
 MEMORY {
-	ram(wrx)	:ORIGIN = 0x801FA100, LENGTH = 0x3F00
+	ram(wrx)	:ORIGIN = 0x801F6200, LENGTH = 0x7E00
 }
 SECTIONS {
-	. = 0x801FA100;
+	. = 0x801F6200;
 	PROVIDE(__RO_START__ = .);
 	.text :
 	{
diff --git a/loader/tonyhax-tpl-ff9.mcs b/loader/tonyhax-tpl-ff9.mcs
new file mode 100644
index 0000000..4001e74
Binary files /dev/null and b/loader/tonyhax-tpl-ff9.mcs differ
diff --git a/loader/tonyhax-tpl-old.mcs b/loader/tonyhax-tpl-old.mcs
new file mode 100644
index 0000000..50c3fa9
Binary files /dev/null and b/loader/tonyhax-tpl-old.mcs differ
diff --git a/tmp/og-tonyhax.0bp/loader/tonyhax-tpl.mcs b/loader/tonyhax-tpl.mcs
index 50c3fa9..0aab208 100644
Binary files a/tmp/og-tonyhax.0bp/loader/tonyhax-tpl.mcs and b/loader/tonyhax-tpl.mcs differ
